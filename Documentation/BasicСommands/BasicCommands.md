---
title: BasicCommands
description: 
published: true
date: 2024-01-25T13:20:14.625Z
tags: 
editor: markdown
dateCreated: 2024-01-25T07:43:02.141Z
---

# Основные команды
## Экраны, диалоги и процессы
- **ShowScreen** – команда переключения экрана. В переменную передается точное название запускаемого экрана. Экраны запускаются в рамках одного процесса, то есть он должен присутствовать в процессе в видимом или невидимом виде. В случае отсутствия система выдаст ошибку. Переменные при этом сохраняются между экранами. `hashMap.put("ShowScreen", "Процесс 1")`
- **BackScreen** – Возврат на предыдущий экран, если вызов был с ShowScreen. 
	`hashMap.put("BackScreen", "")`
- [[Dialogue|ShowDialog]] – команда вызова модального диалога в стандартном виде (визуально отличается от StartScreen). Диалог может содержать поля ввода и другие отображаемые элементы контейнера. При нажатии ОК возникает событие onResult и заполняются переменные полей ввода. 
- [[Dialogue|ShowDialogLayout]], <JSON-структура котнейнера> - определяет содержимое окна диалога. Используется совместно с командой ShowDialog 
	**ShowDialogStyle**, `{"title": "заголовок","yes": "кнопка Да","no": "кнопка Нет"}`
	 Переопределяет заголовок и кнопки диалога 
- [[ModalScreen|StartScreen]] – запуск обычного экрана в режиме модального диалога, но как обычный экран. Отличается от команды ShowDialog внешним видом и тем, что это полноценный экран Т.е. это экран который появляется поверх экрана с кнопками «Ок/Отмена» внизу и ожидает успешного или неуспешного завершения диалога. В случае успешного завершения возникает событие ввода 
- [[RunningProcessesFromProcesses|StartProcess]] или **RunNewProcess**- запуск нового процесса в новом окне с закрытием текущего, т.е. без возможности возврата на текущий процесс. Локальные переменные сохраняются. В качестве параметра передается имя запускаемого процесса. 
- **StartProcessHashMap** - запуск нового процесса в новом окне с возможностью возврата на текущий процесс (т.е. текущий процесс остается на том же месте). Локальные переменные сохраняются. В качестве параметра передается имя запускаемого процесса.
- **ShowProcessResult** , "имя процесса|имя экрана" запускает процесс и выбранный экран, ожидая что в нем произойдет вызов **FinishProcessResult**. Стек переменных при этом на запускаемый и запускающий процесс – общий. Для того чтобы обработать именно нужное событие а не просто событие (по умолчанию listener="имя вызываемого процесса") совместно с этой командой можно установить имя события, которое будет сгенерировано после вызова FinishProcessResult , командой 
- **SetResultListener** , <имя события> **FinishProcessResult**, без параметров – завершает процесс с генерацией события в вызывающем процессе **SetResultListener** , <имя события> - устанавливает имя события при завершении процесса `self.hash_map.put('SetResultListener', listener)` 
- **RunTestScreen** - запуск экрана в режиме замера времени. Используется для замера времени алгоритмов и отрисовки экрана. Измеряемые алгоритмы нужно помещать в «ПриОткрытии» тогда после открытия будет произведено вычисление времени с момента запуска команды до момент отрисовки. После загрузки в переменную TestResult будет помещено время выполнения в миллисекундах. 
- **hold** - удержание экрана. Без параметра. Экран не будет перерисован при отправке обработчика события. 
- **break** - немедленное закрытие экрана без подтверждения **FinishProcess** - немедленное закрытие процесса без подтверждения `hashMap.put("break", "")`
- **ExitProcess** - закрытие процесса с диалогом подтверждения 
	`hashMap.put("ExitProcess", "")`
- **report_table** - открытие экрана с произвольной таблицей просто для отображения. В качестве параметра передается JSON с таблицей
```python
hashMap.put("report_table", json.dumps(json_test, 
							ensure_ascii=False).encode('utf8').decode())
```
- **сentral_table** - установка произвольной таблицы на экран «План-факт». Когда пользователь запустит «План/Факт» из нижней панели он увидит эту таблицу. В качестве параметра передается JSON с таблицей

## Команды управления обработчиками
**RunEvent**, параметр: строка в формате обработчиков - запуск массива любых обработчиков. Т.е. это генерация произвольного события из кода. 
**BreakHandlers** - прерывание выполнения массива обработчиков. Может быть вызвана в каком то обработчике массива (например, проверка ввода) чтобы прервать весь остальной массив 
**BreakHandlersIfError**, без параметра – прерывает дальнейшее выполнение массива обработчиков если в текущем обработчике ошибка

## Уведомления, звуки и речь
Команды уведомлений работают из любого контекста вызова, не только на экранах, но и из фона и команд по расписанию.

[[NotificationsAndToasts|toast]] - всплывающее внизу экрана уведомление. В качестве параметра просто текст сообщения. Работает везде.
`hashMap.put("toast","Привет мир!")`
[[NotificationsAndToasts|basic_notification]] - простое уведомление на экран блокировки c темой и текстом. Работает отовсюду, в том числе из фона. Совместно с сервисом по расписанию можно использовать как замену push. Можно передавать несколько сразу, поэтому в качестве параметра передается JSON- массив. Каждое уведомление должно иметь свой номер. По номеру можно обновлять уже выведенные обновления. Например можно вывести уведомление «Началась обработка» с номером 1, а потом послать еще одно уведомление «Обработка завершена» с номером 1 и ОС обновит на экране существующее уведомление еcли его еще не смахнул пользователь, если его нет – выведет новое. Пример запуска уведомления: 
```python
if hashMap.get("listener") == "basic_send":  
    json_type = [{"number": 2,
			      "title": "Информация",  
                  "message": "Послали basic"}]  
    hashMap.put("basic_notification",f'{json_type}')
```
Тут в JSON зарезервированные слова «number», «title» и «message» - номер, тема и сам текст сообщения
[[NotificationsAndToasts|reply_notification]] - частный случай обычного уведомления с такими же параметрами запуска, только в уведомлении можно нажать кнопку «Ответить» , ввести текст ответа и отправить его. При ответе сработает специальный обработчик конфигурации на котором можно прописать свою логику. В обработчике доступна переменная reply с текстом, который ввел пользователь. Таким образом можно например отправить текст на веб сервис. 
```python
if hashMap.get("listener") == "reply_send":  
    json_type = [{"number": 1,  
                  "title": "Информация",  
                  "message": "Послали reply"}]  
    hashMap.put("reply_notification",f'{json_type}')
```
[[TheSoundSignal|beep]] - воспроизведение звукового сигнала нужного тона.
Совместно с beep: **beep_volume** - громкость, **beep_duration** - продолжительность в мс.
**vibrate** - вибрация. Можно указывать продолжительность в качестве параметра в мс.
`hashMap.put("vibrate", "1000")` - продолжительность 1 секунда
[[SpeechRecognition|speak]] - синтез речи из текста, отовсюду в приложении даже из фона и с выключенным экраном. В качестве параметра передается просто текстовая строка которую надо произнести и система ее воспроизводит. 
**listen** - голосовой ввод (распознавание речи) отовсюду, но с оговоркой что в настоящий момент событие ввода будет сгенерировано только если команда запущена из процесса, так как «события ввода» происходят в контексте процессов. В случае контекста приложения (например из обработчика «При открытии») распознанная переменная будет вставлена в обычные или глобальные переменные, но события не будет.


>[!info]- ## Экраны, диалоги и процессы
>![[ScreensDialogsAndProcesses]]

>[!info]- ## Команды управления обработчиками
>![[HandlerManagementCommands]]

>[!info]- ## Уведомления, звуки и речь
>![[NotificationsSoundsAndSpeech]]

>[!info]- ## Динамическое изменение элементов экрана и конфигурации в целом
>![[DynamicChangeOfScreenElementsAndConfigurationInGeneral]]

>[!info]- ## Прочие команды Экранов. ДОДЕЛАТЬ КОГДА ДОБАВЛЮ! КОМПЬЮТЕРНОЕ ЗРЕНИЕ
>![[OtherScreenCommands]]

>[!info]- ## Прочие функции, запускаемые из фонового сервиса или общих обработчиков
>![[OtherFunctionsLaunchedFromABackgroundServiceOrSharedHandlers]]

>[!info]- ## Команды Python
>![[PythonCommands]]

