---
title: BasicCommands
description: 
published: true
date: 2024-02-06T09:46:43.458Z
tags: обработчик, экран, диалог, процесс, уведомления, toast, screen, handler, beep, speak, звук, речь, notification, show, event, runpy, функции, getjson
editor: markdown
dateCreated: 2024-01-25T07:43:02.141Z
---

# Основные команды
## Экраны, диалоги и процессы
- **ShowScreen** – команда переключения экрана. В переменную передается точное название запускаемого экрана. Экраны запускаются в рамках одного процесса, то есть он должен присутствовать в процессе в видимом или невидимом виде. В случае отсутствия система выдаст ошибку. Переменные при этом сохраняются между экранами. `hashMap.put("ShowScreen", "Процесс 1")`
- **BackScreen** – Возврат на предыдущий экран, если вызов был с ShowScreen. 
	`hashMap.put("BackScreen", "")`
- **ShowDialog** – команда вызова модального диалога в стандартном виде (визуально отличается от StartScreen). Диалог может содержать поля ввода и другие отображаемые элементы контейнера. При нажатии ОК возникает событие onResult и заполняются переменные полей ввода. 
- **ShowDialogLayout**, <JSON-структура котнейнера> - определяет содержимое окна диалога. Используется совместно с командой ShowDialog 
- **ShowDialogStyle**, `{"title": "заголовок","yes": "кнопка Да","no": "кнопка Нет"}`
	 Переопределяет заголовок и кнопки диалога 
- **StartScreen** – запуск обычного экрана в режиме модального диалога, но как обычный экран. Отличается от команды ShowDialog внешним видом и тем, что это полноценный экран Т.е. это экран который появляется поверх экрана с кнопками «Ок/Отмена» внизу и ожидает успешного или неуспешного завершения диалога. В случае успешного завершения возникает событие ввода 
- **StartProcess** или **RunNewProcess**- запуск нового процесса в новом окне с закрытием текущего, т.е. без возможности возврата на текущий процесс. Локальные переменные сохраняются. В качестве параметра передается имя запускаемого процесса. 
- **StartProcessHashMap** - запуск нового процесса в новом окне с возможностью возврата на текущий процесс (т.е. текущий процесс остается на том же месте). Локальные переменные сохраняются. В качестве параметра передается имя запускаемого процесса.
- **ShowProcessResult** , "имя процесса|имя экрана" запускает процесс и выбранный экран, ожидая что в нем произойдет вызов **FinishProcessResult**. Стек переменных при этом на запускаемый и запускающий процесс – общий. Для того чтобы обработать именно нужное событие а не просто событие (по умолчанию listener="имя вызываемого процесса") совместно с этой командой можно установить имя события, которое будет сгенерировано после вызова FinishProcessResult , командой 
- **SetResultListener** , <имя события> **FinishProcessResult**, без параметров – завершает процесс с генерацией события в вызывающем процессе **SetResultListener** , <имя события> - устанавливает имя события при завершении процесса `self.hash_map.put('SetResultListener', listener)` 
- **RunTestScreen** - запуск экрана в режиме замера времени. Используется для замера времени алгоритмов и отрисовки экрана. Измеряемые алгоритмы нужно помещать в «ПриОткрытии» тогда после открытия будет произведено вычисление времени с момента запуска команды до момент отрисовки. После загрузки в переменную TestResult будет помещено время выполнения в миллисекундах. 
- **hold** - удержание экрана. Без параметра. Экран не будет перерисован при отправке обработчика события. 
- **break** - немедленное закрытие экрана без подтверждения **FinishProcess** - немедленное закрытие процесса без подтверждения `hashMap.put("break", "")`
- **ExitProcess** - закрытие процесса с диалогом подтверждения 
	`hashMap.put("ExitProcess", "")`
- **report_table** - открытие экрана с произвольной таблицей просто для отображения. В качестве параметра передается JSON с таблицей
```python
hashMap.put("report_table", json.dumps(json_test, 
							ensure_ascii=False).encode('utf8').decode())
```
- **сentral_table** - установка произвольной таблицы на экран «План-факт». Когда пользователь запустит «План/Факт» из нижней панели он увидит эту таблицу. В качестве параметра передается JSON с таблицей

## Команды управления обработчиками
**RunEvent**, параметр: строка в формате обработчиков - запуск массива любых обработчиков. Т.е. это генерация произвольного события из кода. 
**BreakHandlers** - прерывание выполнения массива обработчиков. Может быть вызвана в каком то обработчике массива (например, проверка ввода) чтобы прервать весь остальной массив 
**BreakHandlersIfError**, без параметра – прерывает дальнейшее выполнение массива обработчиков если в текущем обработчике ошибка

## Уведомления, звуки и речь
Команды уведомлений работают из любого контекста вызова, не только на экранах, но и из фона и команд по расписанию.

[toast](../GeneralFunctionsOfThePlatform/GeneralFunctionsOfThePlatform) - всплывающее внизу экрана уведомление. В качестве параметра просто текст сообщения. Работает везде.
`hashMap.put("toast","Привет мир!")`
[basic_notification](../GeneralFunctionsOfThePlatform/GeneralFunctionsOfThePlatform) - простое уведомление на экран блокировки c темой и текстом. Работает отовсюду, в том числе из фона. Совместно с сервисом по расписанию можно использовать как замену push. Можно передавать несколько сразу, поэтому в качестве параметра передается JSON- массив. Каждое уведомление должно иметь свой номер. По номеру можно обновлять уже выведенные обновления. Например можно вывести уведомление «Началась обработка» с номером 1, а потом послать еще одно уведомление «Обработка завершена» с номером 1 и ОС обновит на экране существующее уведомление еcли его еще не смахнул пользователь, если его нет – выведет новое. Пример запуска уведомления: 
```python
if hashMap.get("listener") == "basic_send":  
    json_type = [{"number": 2,
			      "title": "Информация",  
                  "message": "Послали basic"}]  
    hashMap.put("basic_notification",f'{json_type}')
```
Тут в JSON зарезервированные слова «number», «title» и «message» - номер, тема и сам текст сообщения
[reply_notification](../GeneralFunctionsOfThePlatform/GeneralFunctionsOfThePlatform) - частный случай обычного уведомления с такими же параметрами запуска, только в уведомлении можно нажать кнопку «Ответить» , ввести текст ответа и отправить его. При ответе сработает специальный обработчик конфигурации на котором можно прописать свою логику. В обработчике доступна переменная reply с текстом, который ввел пользователь. Таким образом можно например отправить текст на веб сервис. 
```python
if hashMap.get("listener") == "reply_send":  
    json_type = [{"number": 1,  
                  "title": "Информация",  
                  "message": "Послали reply"}]  
    hashMap.put("reply_notification",f'{json_type}')
```
[beep](../Screens/Screens) - воспроизведение звукового сигнала нужного тона.
Совместно с beep: **beep_volume** - громкость, **beep_duration** - продолжительность в мс.
**vibrate** - вибрация. Можно указывать продолжительность в качестве параметра в мс.
`hashMap.put("vibrate", "1000")` - продолжительность 1 секунда
[speak](../Screens/Screens) - синтез речи из текста, отовсюду в приложении даже из фона и с выключенным экраном. В качестве параметра передается просто текстовая строка которую надо произнести и система ее воспроизводит. 
**listen** - голосовой ввод (распознавание речи) отовсюду, но с оговоркой что в настоящий момент событие ввода будет сгенерировано только если команда запущена из процесса, так как «события ввода» происходят в контексте процессов. В случае контекста приложения (например из обработчика «При открытии») распознанная переменная будет вставлена в обычные или глобальные переменные, но события не будет.

## Динамическое изменение элементов экрана и конфигурации в целом
**getJSONScreen** записывает в переменную **JSONScreen** исходную структуру текущего экрана. 
**setJSONScreen** применяет измененную структуру экрана
**getJSONConfiguration** - считывает в переменную _configuration текущую конфигурацию 
**setJSONConfiguration** - применяет измененную конфигурацию немедленно.

## Прочие команды Экранов
**RunCV** - запуск режима AciveCV из экрана. После завершения ActiveCV в таком варианте запуска, возникает событие ввода с listener=ActiveCV 
**StartMediaGallery** - запуск выбора файла из галереи мультимедиа, котрый можно инициировать из кода (т.е. определить на свою кнопку например) 
**StartCaptureCamera** - запуск камеры 
**SetTitle**, параметра: заголовок экрана - переопределение заголовка экрана 
**PrintPreview** ,параметр:html-строка - запуск окна с предпросмотром html. Для например, печатных форм, которые из этого окна можно отправить на принтер 
**PrintService** команда запуска PDF-документа на печать встроенной службой печати.
[Подробнее](../ComputerVisionAndAugmentedRealityActiveCV/ComputerVisionAndAugmentedRealityActiveCV)

## Прочие функции, запускаемые из фонового сервиса или общих обработчиков
**ShowProcessScreen**, параметр: {"process": "process", "screen": "screen"} - запуск любого экрана любого процесса из любого состояния приложения (в случае если основной контекст приложения запущен) 
**SpeechRecognitionListener**, параметр: задержка - запуск распознавания речи с паузой для ожидания ответа 
**SendIntent** - отправка из фона некоего события ввода, на которое подписаны экраны и ActiveCV (там возникает событие ввода) 
**BackgroundCommand** - команда, которой можно передать управление в фоновый Сервис событий и запустить там какой то обработчик

## Команды Python
**RunPy** - запускает синхронное выполнение скрипта Python в UI-потоке приложения. В качестве параметра передается скрипт в виде Base64-строки. Устаревшее, рекомендуется использовать запуск массива обработчиков. 
**RunPyThreadDef** - запускает асинхронное фоновое выполнение скрипта Python. В качестве параметра передается имя функции 
**RunPyThreadProgressDef** - аналогично команде **RunPyThread** , но запускает прогресс-бар, который блокирует UI-поток. В качестве аргумента - имя функции.

