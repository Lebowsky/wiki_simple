---
title: CommonScreenElements
description: 
published: true
date: 2024-02-16T10:11:13.964Z
tags: 
editor: markdown
dateCreated: 2024-02-16T10:06:20.091Z
---

# Общие элементы экранов
## Сканирование штрихкода
Если на экране требуется распознавание штрихкода, то необходимо добавить на экран элемент «Штрих-код» и указать переменную(variable), которую будет воспринимать hashMap, в которую он будет записываться по факту сканирования.
<details>
<summary>Фотогайд</summary>
<br>
<img src="/files/Pastedimage20240112172533.png" width=700>
<br>
<img src="/files/Pastedimage20240112172558.png" width=700> 
<br>
<img src="/files/Pastedimage20240112172746.png" width=700> 
</details>

Если на устройстве есть аппаратный сканер, желательно указать галочку «Аппаратный сканер» в настройках. В противном случае на экране будет присутствовать кнопка сканирования через камеру устройства. Соответственно, при сканировании через камеру при добавлении элемента Штрих-код подразумевается что будет нажиматься парящая кнопка. Также в настройках можно включить подсветку. Также при использовании Bluetooth сканеров в режиме SSP сопряжения необходимо активировать Использовать Bluetooth и выбрать устройство и суффикс (это все обычно программируется на устройстве штрих-кодами из инструкции). Bluetooth сканеры обычно могут работать и в режиме HID но в таком случае на экране нельзя размещать другие элементы ввода – они будут перехватывать строку. Аппаратный сканер ТСД может быть запрограммирован в режиме HID (в разрыв клавиатуры) с суффиксом CR/LF на конце. Либо он может быть запрограммирован на передачу сообщения через подписку на intent. Второй вариант лучше, потому что поля ввода не перехватывают такое сообщение и можно располагать ввод штрихкода с полями ввода на одном экране. Для использования в этом режиме надо включить галку «Использовать подписку на события сканера» и заполнить поля. Заполнение полей индивидульно для разных моделей, информацию ищите в документации либо в ПО ТСД.
[![Pastedimage20240112173214.png](/files/Pastedimage20240112172746.png =700x)](/files/Pastedimage20240112172746.png)
Знак сканирования через камеру

## Передача картинки
На экране может быть выведена картинка на том месте где находится элемент picture. Картинка передается через обычную переменную в виде строки Base64.
```python
def screen_on_start(hashMap):
    hashMap.put("picture", base64_cod_picture)  
    return hashMap
```

<details>
<summary>Фотогайд</summary>
<br>
<img src="/files/Pastedimage20240112183031.png" width=700>
<br>
<img src="/files/Pastedimage20240112182924.png" width=400>   
</details>

## Прием картинки с камеры
В составе экрана можно разместить элемент «Фото с камеры» , тогда на экране появится кнопка камеры. И это изображение можно передавать в переменную base64 либо выдавать ссылку на файл (с флагом mm_local).

## Горизонтальная галерея мультимедиа
Элемент управления «Горизонтальная галерея мультимедиа» это и визуальный и активный элемент, который позволяет упростить работу с изображениями. Он предназначен для визуализации в виде миниатюр массива мультимедиа. Входная переменная - это JSON массив либо идентификаторов файлов (в случае флага mm_local) типа [id1, id2] и т.д. либо JSON массив вида 
```json
[{  
    "uid": id1,  
    "base64": "данные картинки 1"},  
{  
    "uid": id2,  
    "base64": "данные картинки 2"}]
```
то есть массив, содержащий непосредственно данные. Сам массив формируется когда добавляются мультимедиа с камеры или из галереи, либо удаляются. То есть для функционирования достаточно разместить элемент галереи и «Фото с камеры» или «Фото с галереи» и указать любую переменную. При работе с мультимедиа или удалении будут возникать события ввода, при которых переменную с массивом можно например сохранить. Удобнее всего это делать в режиме NoSQL (именно так устроены примеры в демо-базе). Причем даже если хранение у вас на SQL все разно сами фото можно хранить в объектах NoSQL и ссылаться на них. Для удаление нужно пометить миниатюры долгим тапом.
<details>
<summary>Фотогайд</summary>
<br>
<img src="/files/Pastedimage20240115103710.png" width=700>
<br>
<img src="/files/Pastedimage20240115103735.png" width=700>  
<br> 
<img src="/files/Pastedimage20240115104401.png" width=400>   
</details>

## Таймер экрана
На экране можно определить таймер, который будет периодически генерировать событие ввода (частота таймера задается в общих настройках). Данная функция была введена до того, как в платформе появились асинхронные обработчики. Большинство сценариев для которых нужен таймер гораздо более эффективно реализуются на асинхроне и системе не нужно постоянно дергать экран, более того это еще и более быстрая реакция. Поэтому прежде чем использовать таймер, рекомендуется посмотреть в сторону асинхронных вызовов экранов или сервиса событий
### Запуска таймеров из кода

Таймеры (повторяющиеся в фоне задания) можно определить в конфигурации и также в новом релизе запустить/остановить из кода.
- **StartTimers** , пустой параметр – инициализирует объект таймеров 
- **StartTimer**, `{"handler": "массив обработчиков", "period": "периодичность, мс"}` - добавляет новый таймер и запускает его 
- **StopTimers**, пустой параметр – останавливает объект таймеров и удаляет все ранее добавленные таймеры (командой StartTimer)

[![Pastedimage20240122162641.png](/files/Pastedimage20240122162641.png =700x)](/files/Pastedimage20240122162641.png)


## Сообщение об ошибке
В режиме онлайн заполнение переменной Сообщение об ошибке (ErrorMessage) вызывает показ надписи с текстом ошибки внизу экрана. Прерывание по exception в других обработчиках таже вызывает показ ошибки внизу экрана
```Python
hashMap.put("ErrorMessage", "Ошибка")
```

## Видимость элементов
Для управления видимостью отдельных элементов экрана следует использовать команду Show_<Идентификатор элемента>
```Python
hashMap.put("Show_element", -1)
```
element - переменная элемента (переменная=идентификатор).
Значения могут быть: 
- 1 виден , 
- 0 не виден, без освобождения места, 
- -1 не виден, с освобождением места

## Режим работы с мультимедиа и файлами по ссылкам (флаг mm_local)
Можно хранить мультимедиа и галереи в виде base64-строки, но это довольно ресурсозатратный процесс. Вследствие того что кодирование и раскодирование занимает время и место, обычно при таком подходе мультимедиа сильно сжимают и по размеру и по компрессии. Альтернатива этому новый режим который задействуется переменной **mm_local**
```Python
hashMap.put("mm_local", "")
```
При таком режиме файлы хранятся на диске, а в Переменных хранятся только их идентификаторы. Т.е. при попадании новой например картинки в устройство он сохраняется на диске, взамен выдается идентификатор, далее операции производятся с идентификатором а когда нужно отправить эту картинку по синхронизации по идентификатору можно получить сам файл. Имя файла совпадает с идентификатором. Файлы хранятся во внутреннем хранилище приложения. Имя файла - сгенерированный uid. картинки можно не сжимать при таком подходе но все равно есть возможность сжимать. Для этого используются флаги **mm_compression** и **mm_size** где в качестве параметра указывается процент от 100% реального размера и 100% качества.
`hashMap.put("mm_compression", "70")` - это будет компрессия 70%. 
`hashMap.put("mm_size", "50")` - это будет размер 50%
Использование этих 3х флагов очень простое - если флаги объявлены на экране (в «При открытии» например) то активные элементы (добавление фото, галерея и т.д.) ведут себя соответствующе - возвращают не base64 а ссылки на файлы. 
Файлы, генерируемые на устройстве, это в том числе изображения с камеры или медиагалереи устройства, загружаемые с ключом mm_local. У подобных файлов при сохранении генерируется uuid, по которому к нему можно обратиться. Этот uuid равен имени файла. Можно просто работать с именем файла, запоминая его в своих структурах данных. Например при фотографировании в режиме mm_local в переменную (допустим переменная камеры называется photo) сохраняется абсолютный путь с приставкой _path, то есть в данном случае будет переменная photo_path.
```python
if hashMap.get("listener") == "photo":  
    hashMap.put("toast", hashMap.get("photo_path"))
```
Вывод toast с путем к файлу
Сами ссылки хранятся в СУБД на устройстве в виде пар «идентификатор-путь к файлу» и могут быть получены в любой момент командой «getfiles» 
```Python
hashMap.put("getfiles", "")
```
и выданы в событии «_results» в переменную «_files». То есть всегда можно узнать абсолютный путь к файлу, получить файл и сделать с ним что угодно. Например наложить фильтры, удалить и т.д. Кроме того при синхронизации (при входящих файлах) следует также использовать специальную команду «addfile_идентификатор, путь к файлу» для того чтобы записать в массив _files идентификатор и путь.

## Режим работы с файлами изображений напрямую по абсолютному пути (через ~)
Во всех визуальных элементах (картинка на форме, картинка в карточке, в диалоге, в плитке и т.д.) возможно указание непосредственно файла на диске. Этот подход обеспечивает гораздо более высокую производительность нежели работа через base64. Особенно это заметно в больших списках где используется много изображений. Для передачи в переменную картинки следует использовать путь к файлу в файловой системе устройства с префиксом ~. Абсолютные пути к файлам могут быть доставлены в переменную _files командой getfiles, а также для обработчиков на python доступна коллекция _files через которую можно получить, записать файл по uid.
Также для отправки файлов используются фоновые команды (выполняют обмен в фоне, не блокируя ui-поток):
(post_file_УИДфайла, url) , где УИДфайла - уид картинки, url – ссылка на POST команду HTTP сервера на который отправится картинка. 
Например: 
```Python
hashMap.put("post_file_"+str(ID), http://...)
```
(post_file_array_ПерменнаяМассив, url), где ПерменнаяМассив – переменная такая, которая используется для галереи, т.е. если например на экране расположена галерея то дополнительно ничего делать не надо можно просто написать 
```Python
hashMap.put("post_file_array_photoArray", "http://...")
```

## Awesome-шрифт
Это набор пиктограмм, с помощью которого можно сделать свои красивые кнопки, сделать иконки на карточках, экранах и т.д.
Используется бесплатный набор из 1001 иконки [https://fontawesome.com/v5.15/icons?d=gallery&p=2&s=solid&m=free](https://fontawesome.com/v5.15/icons?d=gallery&p=2&s=solid&m=free) Для того чтобы использовать, надо взять на сайте Unicode -код например f6be и присвоить переменной с префиксом # – т.е. #f6be, который потом указать в заголовке кнопки или надписи. Это можно использовать в элементах экранов, диалогов и т.д.:

- Кнопка
- Список кнопок
- Горизонтальный список кнопок
- Надпись

<details>
<summary>Фотогайд</summary>
<br>
<img src="/files/Pastedimage20240115122642.png" width=850>
<br>
<img src="/files/Pastedimage20240115122700.png" width=400>      
</details>

## Плавающие кнопки
В ряду стандартных кнопок экрана можно добавлять свои кнопки (элемент «Плавающая кнопка»). Можно использовать стандартную иконку (выбрать из Иконка), либо установить через «#» [Awesome- иконку](Awesome-font.md), аналогично тому, как это сделано в других случаях. В этом случае возможно потребуется дополнительно отцентрировать иконку, для этого после надписи можно указать смещение по горизонтали и вертикали. Например: (#f1d8;1;-20)
[![Pastedimage20240122162137.png](/files/Pastedimage20240115122700.png =400x)](/files/Pastedimage20240115122700.png)