---
title: OtherInterfaceElements
description: 
published: true
date: 2024-02-16T10:11:52.876Z
tags: 
editor: markdown
dateCreated: 2024-02-16T08:24:27.675Z
---

# Прочие элементы интерфейса
## Звуковой сигнал
Можно воспроизвести «бип» - один из 100, заложенный в Андроиде, если присвоить в переменную `beep` значение от 1 до 99, либо оставить пустой - тогда будет звук по умолчанию. 
```Python
hashMap.put("beep", "")
```
Это работает и в онлайн и в оффлайн (через присвоение переменных). Примеры звуков:[https://developer.android.com/reference/android/media/ToneGenerator#TONE_CDMA_ABBR_REORDER](https://developer.android.com/reference/android/media/ToneGenerator#TONE_CDMA_ABBR_REORDER)

## Синтез речи
Можно воспроизводить речь, используя команду-переменную **speak** , например
```Python
hashMap.put("speak", "Привет, мир!")`
```
Данная команда работает как в контексте экранов так и в контексте фонового Сервиса событий

## Распознавание речи
На экране можно размесить элемент Голос, с переменной, в которую будет записываться распознанная строка. По нажатию на кнопку запускается распознавание, когда вы закончите говорить возвращается результат - событие экрана с listener="voice" и результат распознавания в переменной.
```python
if hashMap.get("listener") == "voice":  
    result_voice = hashMap.get('voice')  
    hashMap.put("result_voice", result_voice)
```
Также, можно организовать работу с речью вне экрана (в фоновом Сервисе событий) и например запускать распознавание речи не по кнопке а из кода, командой voice (в случае использования сервиса, результат будет возвращаться в Общие события, на него можно подписаться). В команде voice можно определить период ожидания пользователя. Таким образом команды [[SpeechSynthesis|speak]] и voice могут быть использованы для сборки голосового ассистента поверх всей системы, но взаимодействующего с логикой приложения и с экранами и общими функциями (из Сервиса событий можно взаимодействовать с экранами)
<details>
<summary>Фотогайд</summary>
<br>
<img src="/files/Pastedimage20240115144953.png" width=700>
<br>
<img src="/files/Pastedimage20240115145011.png" width=700> 
<br>     
<img src="/files/Pastedimage20240115145105.png" width=400>  
<img src="/files/Pastedimage20240115145852.png" width=400>    
</details>

## Контейнеры
Контейнер по умолчанию может вместить неограниченное количество элементов т.е. имеет прокрутку содержимого. Но в случае если в нем располагаются элементы, содержащие прокрутку, например таблица или список карточек это ставит систему в неразрешимое противоречие. Таблицу можно разместить в таком контейнере но она не будет иметь собственную прокрутку содержимого а будет пролистываться с другими элементами. Если нужно разместить эелемент с прокруткой и чтобы она работала(а сам элемент не сдвигался) нужно в экране поставить галочку Отключить прокрутку для корневого контейнера
### Элементы контейнера
Контейнеры включают в себя собственные визуальные элементы. При этом невизуальные – Голос, ШтрихКод и т.д. могут быть в экране помимо корневого контейнера и использоваться. Обработка переменных происходит в обработчиках экранов. Сколько бы не было вложенных контейнеров все обработчики – в экране. Элементы контейнера отличаются следующими свойствами:
- Их может быть неограниченное количество каждого типа
- На каждый из них может быть задано собственное оформление
- Для кнопок есть галочка «Не обновлять экран» - происходит только отправка запроса или выполнение офлайн обработчика. Перерисовка не происходит
- Для полей ввода можно задавать предопределенные значения
- Можно задавать оформление элементов непосредственно в элементах, контейнарах, а можно исопльзовать справочние Элементы стилей, как шаблон. Т.е. создать справочник, а потом использовтаь его для заполнения настроек оформления в экранах

Оформление включат в себя элементы «Высота», «Ширина» и «Вес» - они полностью аналогичны контейнерам. Т.е. например если поставить у кнопки ширину и высоту «На весь контейнер» то она займет весь контейнер. Также элементы оформления Цвет фона, цвет текста – установка цветов в HEX кодировке вместе с символом #. Посмотреть палитру можно в интернете. Андроид рекомендует использовать «материал» цвета например с ними удобно работать вот [тут](https://materialuicolors.co/).Можно копировать и вставлять в поля. Размер текста – числовой размер текста Выравнивание – Лево, Право, Центр. Выравнивание зависит от ширины и высоты. Например если надпись в контейнере котрый «По размеру элементов» по ширине, то от установки выранивания «По центру» ничего не изменится. Но если вам надо расположить надпись по центру экрана – вам надо сделать размер контейнера «На весь контейнер» по ширине и поставить Выравнивание «По центру» Иконка – выбор из нескольких иконок для кнопок.

Виды элементов контейнера:
- Контейнер – вложенный контейнер
- Картинка – картинка в виде строки base 64. Работа аналогична картинкам обычного экрана
- Диаграмма – диаграмма типа «Круговая», «Столбики» и «Линейная». Установка столбцовой и линейной диаграммы возможна по сериям. Установка значений производится путем передачи json строки.
- Индикатор – индикатор со своей шкалой. Возможна установка минимального и максимального значения, границ красной, желтой и зеленой зон и самого значения. Установка происходит через передачу json строки.
- Список – простой выпадающий список. Элементы можно задать в виде строки с разделителем «;» через переменную или прямо в кострукторе. В списке всегда будет выбран первый элемент, поэтому если требуется чтобы по умолчанию было пусто , первым элементом следует определить пустую строку или что то подобное. Например: ("Выберите значение";Первый;Второй). В «Переменную» при этом возвращается выбранное значение. Можно указать значение по умолчанию - то значение которое будет выбрано при открытии. Для этого нужно в стек переменных поместить переменную с именем переменной результата.Например, если перменная - res то помещаем в 
```Python
hashMap.put("res", "Второй")
```
- Таблица – таблица на экране. Может быть несколько таблиц расположенных как угодно.
- Список карточек – прокручиваемый список карточек
- Плитки – прокручиваемый список карточек (см. также «[Плитки и плиточное главное меню](../GeneralFunctionsOfThePlatform/GeneralFunctionsOfThePlatform)»)
- Надпись – их может быть сколько угодно с любым оформлением
- Кнопка – в отличии от «упрощенного режима» кнопки не располагаются в блоках а добавляются по одной и каждая вызывает событие при нажатии.
- Поле ввода число и Поле ввода строка – может быть произвольное количество полей. В отличии от упрощенного режима «Поле ввода» не имеет заголовка. Если нужен заголовок – то рядом нужно поместить «Надпись» В «Заполнение поля» можно поместить значение или переменную для начального заполнения
- Поле ввода пароля - поле ввода со скрытым текстом
- Современное поле ввода - настраиваемое поле ввода (см. «[Современное поле ввода](../GeneralFunctionsOfThePlatform/GeneralFunctionsOfThePlatform)»)
- Поле ввода автозаполнение списка - поле ввода с автозаполнением. В «Заполнение поля» надо передать переменную, содержащую список возможных вариантов разделенный «;». В остальном обычное поле ввода.
- Поле ввода с событием - обычное текстовое поле,но генерирующее событие ввода при каждом набранном символе. Можно исопльзовать для обновления таблицы на экране, зависимой от ввода например.
- Флажок – логическое значение. В Переменные записывается “true”/”false” - именно в строковом виде.

## Функции авторизации и загрузки конфигурации
Можно организовать экран входа в систему который будет запускаться при запуске приложения и пункт основного меню для перелогирования. Для того чтобы процесс запускался при входе в приложение нужно поставить галочку «Запустить при старте» Есть функции логина - доступ к настройкам сервиса(экран «Настройки») и перезапуску конфигурации. В Переменные по умолчанию записываются переменные CLIENT_CODE, WS_URL, WS_USER, WS_PASS с настройками онлайн-подключения по умолчанию. Также появился элемент контейнера «Поле ввода пароля». Также команды RunLogin или RunSaveLogin - первая просто загружает с настройками, вторая - сохраняет настройки. Этим командам надо передать JSON типа 
```json
{"code": "code",
 "user": "user",
 "password": "pass"}
```
 Также в JSON можно передавать "backendURL" и "backendUser" команда SetSettingsJSON которая загружает любые настройки в виде JSON, как если бы они были переданы через файл или через QR, в т.ч настройки хостинга конфигурации или сам текст конфигурации («configuration») Также есть команды которые позволяют переопределить любой кусок текста конфигурации setJSONConfiguration (а получить предварительно getJSONConfiguration) таким образом можно например включить/выключить некоторые процессы при загрузке. Таким образом на экране логина можно управлять загружаемой конфигурацией или переопределять ее.