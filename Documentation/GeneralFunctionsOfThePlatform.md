---
title: GeneralFunctionsOfThePlatform
description: 
published: true
date: 2024-02-16T07:58:09.263Z
tags: диалог, уведомления, toast, изображения, таблицы, карточки, списки, плитки, корзина, современное поле ввода, модальный экран, пин-код
editor: markdown
dateCreated: 2024-01-25T07:43:31.012Z
---

# Таблицы
Через переменные в виде строки json можно передавать произвольные таблицы и размещать их в разных местах программы. Под таблицей подразумевается табличная форма - колонки и строки. Также через элемент «Таблица» можно определить список, аналогичный списку карточек- подробнее в «Список карточек»

Произвольная таблица может быть представлена в виде:

- **Элемента экрана**, вместе с другими элементами. Для этого нужно использовать элемент экрана «Таблица» и в переменной передать строку json в специальном формате
- Переопределить нажатие центральной кнопки **План-факт**. Старый формат также действует, но если задана произвольная таблица то это имеет приоритет. Для этого нужно вставить переменную **central_table**. 
```Python
hashMap.put("central_table", CтpoкaJSON)
```
- Вызвать отдельное окно с таблицей по какому то событию (например по нажатию кнопки) с заполненной таблицей на весь экран. Для этого нужно использовать переменную **report_table**
```Python
hashMap.put("report_table",CтpoкaJSON)
```

В структуре json можно описывать :

- Столбцы таблицы – имя, заголовок, ширину колонки
- Общие опции таблицы – размер шрифта, скрыть заголовок, отключить подсветку линий через строку
- Непосредственно данные в ячейках
- Раскраску отдельных ячеек произвольными цветами

Структура формата таблицы не зависит от места использования таблицы – она общая.
Пример формата:
```json
{
"type": "table",
"textsize": "25",
"hidecaption": "true",
"hideinterline": "true",
"columns": [
  {
    "name": "nom",
    "header": "Товар",
    "weight": "2"
  },
  {
    "name": "qty",
    "header": "Кол-во",
    "weight": "1"
  },
  {
    "name": "price",
    "header": "Цена",
    "weight": "1"
  }
],
"rows": [
  {
    "name": "Процессов Intel Core 9 OEM",
    "qty": "5",
    "price": "15500.00"
  },
  {
    "name": "Процессов Intel Core 5 BOX",
    "qty": "-2",
    "price": "12500.00"
  },
  {
    "name": "Процессов Intel Core 5 (OEM)",
    "qty": "2",
    "price": "11500.00"
  }
],
"colorcells": [
  {
    "row": "1",
    "column": "1",
    "color": "#d81b60"
  }
]
}
```

Атрибут type обязательный он должен быть всегда значение «table»
> ### Атрибуты таблиц
>- **textsize** -необязательный – отвечает за размер текста
>- **hidecaption** – необязательный – не выводить шапку таблицы
>- **hideinterline** – необязательный – не выводить раскраску строк
>- **borders** – необязательный – выводит границы ячеек таблицы
>- **columns** _обязательный_ массив в котором описываются колонки. 
>**name** – внутреннее имя 
>**header** -отображаемый заголовок 
>**weight** – ширина колонки в виде относительного веса 
>**gravity** - выравнивание текста (left,right,center). Если задать все колонки в 1 то они будут равны.
>- **rows** _обязательный_ массив в котором описываются строки. Каждый элемент имеет имя, совпадающее с именем столбца и значение
>- **colorcells** _необязательный*_ массив– подсветка произвольных ячеек нужным цветом. Строка и столбец задаются номерами начиная с 0. Цвет (color) – в HEX виде.

Нажатие на строку таблицы таблицы вызывает _событие ввода_ и передачи данных на сервер. Выбранная строка - объект JSON сериализуется в переменную **selected_line**

Для «самостоятельно режима» при клике по таблице возвращается не json. Программа ищет в выделенной строке поля **id**, **order** и **orderRef** и если они есть, записывает в переменные значения `selected_line_id`, `order` и `orderRef`

##  Адаптер таблицы
При работе через закладку Offline&REST в самостоятельном режиме источником данных могут служить либо запрос к SQL либо GET-запрос. Для того чтобы оформить колонки таблицы в строке запроса указывается _адаптер_ - справочник в котором прописываются видимые заголовки колонок, ширина колонок и ключ(значение которое будет возвращаться по клику)

# Списки карточек
## Кастомные списки
Можно определить любую разметку для элемента списка на основе структуры контейнера. Для этого используется либо элемент «Список карточек» с структурой списка
```json
{"customcards": 
	{
	"layout": {..контейнер..},
	"cardsdata": [{данные},{},{}]
	} 
}
```
Для отображения в виде «карточек», либо элемент «Таблица» с переменной типа
```json
{"customcards": 
	{
	"layout": {..контейнер..},
	"tabledata": [{данные},{},{}]
	} 
}
```
Для отображения в виде сплошного списка без выделения карточек.
Контейнер можно разработать в «редакторе» и перенести через буфер обмена в код переменной

Данные в обоих случаях – массив JSON -объектов по одному на каждый элемент списка. В которых перечисляются переменные, отображаемые в контейнере. Также могут быть добавлены любые другие.

Также отдельно нужно выделить key – ключ, возвращаемый при нажатии

Пример определения такой переменной в python:
```python
form_custom = { "customcards":         {
        "options":{
          "search_enabled":True,
          "save_position":True
        },

        "layout": {
        "type": "LinearLayout",
        "orientation": "vertical",
        "height": "match_parent",
        "width": "match_parent",
        "weight": "0",
        "Elements": [
        {
            "type": "LinearLayout",
            "orientation": "horizontal",
            "height": "wrap_content",
            "width": "match_parent",
            "weight": "0",
            "Elements": [
            {
            "type": "Picture",
            "show_by_condition": "",
            "Value": "@pic1",
            "NoRefresh": False,
            "document_type": "",
            "mask": "",
            "Variable": "",
            "TextSize": "16",
            "TextColor": "#DB7093",
            "TextBold": True,
            "TextItalic": False,
            "BackgroundColor": "",
            "width": "match_parent",
            "height": "wrap_content",
            "weight": 2
            },
            {
            "type": "LinearLayout",
            "orientation": "vertical",
            "height": "wrap_content",
            "width": "match_parent",
            "weight": "1",
            "Elements": [
            {
                "type": "TextView",
                "show_by_condition": "",
                "Value": "@string1",
                "NoRefresh": False,
                "document_type": "",
                "mask": "",
                "Variable": ""
            },
            {
                "type": "TextView",
                "show_by_condition": "",
                "Value": "@string2",
                "NoRefresh": False,
                "document_type": "",
                "mask": "",
                "Variable": ""
            },
            {
                "type": "TextView",
                "show_by_condition": "",
                "Value": "@string3",
                "NoRefresh": False,
                "document_type": "",
                "mask": "",
                "Variable": ""
            }
            ]
            },
            {
            "type": "TextView",
            "show_by_condition": "",
            "Value": "@val",
            "NoRefresh": False,
            "document_type": "",
            "mask": "",
            "Variable": "",
            "TextSize": "16",
            "TextColor": "#DB7093",
            "TextBold": True,
            "TextItalic": False,
            "BackgroundColor": "",
            "width": "match_parent",
            "height": "wrap_content",
            "weight": 2
            }
            ]
        },
        {
            "type": "TextView",
            "show_by_condition": "",
            "Value": "@descr",
            "NoRefresh": False,
            "document_type": "",
            "mask": "",
            "Variable": "",
            "TextSize": "-1",
            "TextColor": "#6F9393",
            "TextBold": False,
            "TextItalic": True,
            "BackgroundColor": "",
            "width": "wrap_content",
            "height": "wrap_content",
            "weight": 0
        }
        ]
    }

}
}

form_custom["customcards"]["cardsdata"]=[]
for element in range(0,2):
    filling = {
    "key": str(element),
    "descr": "Pos. " + str(element),
	"string1": "Котята",  
	"string2": "2 штуки",  
	"string3": "сидят"
  }
    form_custom["customcards"]["cardsdata"].append(filling)

hashMap.put("cards",json.dumps(form_custom,ensure_ascii=False).encode('utf8').decode())
```
[![Pastedimage20240115172510.png](/files/Pastedimage20240115172510.png =450x)](/files/Pastedimage20240115172510.png)

## Использование активных элементов в кастомных списках
Доступно использование активных элементов: Кнопки, Меню и Флажки. Для этого их нужно разместить в контейнере в любом количестве и любом месте. При нажатии они будут порождать отдельное от нажатия на саму карточку событие с `listener = LayoutAction`, также помещается переменные layout_listener и card_data. В первой содержится переменная элемента, породившего событие (кнопки, пункта меню, флажка). Во второй - данные карточки, включая позицию в виде JSON-строки. Для добавления меню нужно поместить в контейнер элемент PopupMenuButton, в качестве значения передать список пунктов меню, разделенных точкой с запятой. Например «Первый;Второй» Флажок ведет себя как обычный флажок, плюс выполняет необходимое действие - при изменении состояния, он прописывает значение состояния в датасет переменной списка, чтобы при обновлении списка показать текущее состояние.

## Использование поиска, переопределение поиска
Для того, чтобы на экране появился автоматический поиск по таблице в тулбаре, необходимо добавить в JSON списка в раздел «options» поле «search_enabled» с значением True. Также по желанию, можно передать поле, по которому будет вестись поиск «search_string» - это строка, в которую для каждой карточки можно поместить строку с данными поиска. Поиск ведется по вхождению подстроки поиска в эту строку. Если такого поля нет в карточке, то будет вестись поиск по всем полям объекта данных. Этот поиск можно переопределить - пустить вводимый текст на события. Для этого в раздел «options» необходимо добавить «override_search» с значением True, тогда при вводе текста в поле поиска будет генерироваться событие «Search», а в переменную «SearchString» введенный текст
```json
{"customcards": {  
    "options": {  
        "search_enabled": True,  
        "save_position": True  
	 }
   ............
   }
}
```
![Pastedimage20240115174217.png](/files/Pastedimage20240115174217.png =450x)

## Сохранение позиции в списке
Для того, чтобы на экране появился автоматический поиск по таблице в тулбаре, необходимо добавить в JSON списка в раздел «options» поле «save_position» с значением True. При наступлении события и перерисовке списка, список останется на том же месте.
```json
{"customcards": {  
    "options": {  
        "search_enabled": True,  
        "save_position": True  
	 }
   ............
   }
}
```

## Использование групп
Можно сгруппировать список карточек (работает только со списком карточек). Для этого в нужных местах датасета нужно вставить объекты с полем «group» (предопределенное поле)

## Предопределенные списки
Карточки могут содержать 1 картинку либо, если ее нет то ее место сдвигается и остаются поля. Полей может быть сколько угодно. Они состоят из пар «Заголовок»-«Значение», но заголовка опять же может не быть. При этом можно менять размер и цвет текста, а в самих полях писать HTML-текст.
Списки карточек могут работать в онлайн режиме, оффлайн режиме и режиме связи с бекендом.
В онлайн режиме источник данных и правила оформления задаются в виде JSON-строки на сервере. Например это может быть так:
```json
{
  "cards": [
  {
    "key": "key_00320055",
    "picture": "",
    "description": "какой то комментарий",
    "items": [
      {
        "key": "",
        "value": "Материнская плата GIGABYTE B450M DS3H",
        "size": "15",
        "color": "#1b31c2",
        "caption_size": "12",
        "caption_color": "#1b31c2"
      },
      {
        "key": "Цена",
        "value": 5500,
        "size": "25",
        "color": "#131e61"
      }
    ]
  },
  {
    "key": "key_00320023",
    "items": [
      {
        "key": "",
        "value": "Процессор intel i7",
        "size": "15",
        "color": "#1b31c2",
        "caption_size": "12",
        "caption_color": "#1b31c2"
      },
      {
        "key": "Цена",
        "value": 17500,
        "size": "25",
        "color": "#131e61",
        "caption_size": "12",
        "caption_color": "#1b31c2"
      },
      {
        "key": "Скидка",
        "value": 1500,
        "size": "25",
        "color": "#DC143C",
        "caption_size": "15",
        "caption_color": "#DC143C"
      }
    ]
  }
]
}
```
В каждой карточке присутствует ключевое поле. В JSON это- «key». По нему в дальнейшем идет обработка клика по карточке.

Клик по карточке порождает событие «CardsClick» и добавляет в структуру переменных переменные «selected_card_key» и «selected_card_position» содержащие ключ и позицию карточки.

# Плитки и плиточное главное меню
## Переопределение стартового меню
[![Pastedimage20240116152748.png](/files/Pastedimage20240116152748.png =450x)](/files/Pastedimage20240116152748.png)
Меню можно сделать красивым и информативным используя плитки. Дело не только в эстетике - на плитки можно выводить оперативную информацию сразу, не погружаясь в процесс. Например количество текущих заказов или задач. Для этого плитка должна обновляться в фоновом процессе (например По расписанию Python), но чтобы происходила отрисовка нужно еще добавлять команду **UpdateMenu**. Таким образом меняя переменные в JSON будут менять данные на плитках в фоне, независимо от состояния приложения (даже в режиме сна).

Чтобы переключить режим меню нужно в конфигурации выбрать «Вид стартового экрана» - «Плитки», а также заполнить «Плиточный контейнер для запуска» (откуда будут браться шаблоны) и задать какую то глобальную переменную , например «_tiles» через которую из обработчиков будет передаваться состав плиток. Как минимум нужно определить эту переменную в обработчике «При запуске Python» конфигурации.

## Плитки и плиточное главное меню
Плитки - это элемент контейнера который можно вывести на экран, либо использовать как главное меню программы (стартовый экран). Структура карточки может быть любая - она задается в контейнере точно также как в контейнере задаются элементы экрана. При этом можно использовать все те же визуальные элементы что и в экранах - надписи, картинки, диаграммы, индикатор а также кэшированные картинки. Поля ввода и другие элементы ввода использовать нельзя.
Плитки могут визуально заменить список карточек при не очень большом количестве элементов (построение каждой плитки по шаблону занимает некоторое время и например 1000 плиток будут несколько притормаживать)
Размер (высота) плиток зависит от количества карточек в горизонтальном ряду. Есть 3 вида размера:
> - средний размер - при количестве плиток от 2 до 3 в ряду. Высота = ширина экрана/3.14  
> - мелкий размер - количество от 4 и выше. Высота - средний размер/2
> - большой размер - при одной плитке в ряду. Высота - минимально - такая же как у среднего размера, при необходимости - увеличивается.

Плитки задаются в JSON переменной как массив рядов, а каждый ряд - тоже массив, содержащий список плиток в ряду.
При этом каждая плитка в обязательном порядке содержит:
> - поле **template** - имя экрана, содержащего контейнер с шаблоном - то есть экран в составе конфигурации в котором определена структура плитки. Он может быть один на все плитки, но хотя бы один шаблон должен быть обязательно. Т.е. из экрана берется корневой контейнер и его структура является структурой плитки
> - объект **data** - объект содержащий значения переменных плитки. Т.е. в шаблоне определяется привязка переменных через @ , а в data для каждой плитки передаются данные
> - поле **color** - цвет плитки
> - поля **start_screen** и **start_process** - запуск экрана и процесса. При нажатии на плитку будет запущен процесс, указанный в плитке в поле start_process либо экран текущего процесса в поле start_screen. Вообще плиточный экран по умолчанию воспринимается как некое меню для запуска процессов – т.е. при нажатии должен стартовать процесс, а при завершении процесса возвращаться на меню. Для этого нужно указывать start_process в плитке. Но также можно использовать его для как шаг процесса как например используется таблица или список плиток – для запуска экрана с закрытием текущего шага. Для этого используется start_screen
> - плитка может содержать поле **key** которое передается в обработчик при нажатии

Также в общем объекте определено поле **background_color** - в нем задается фон под плитками.
<details>
<summary>Фотогайд</summary>
<br>
<img src="/files/Pastedimage20240116151639.png" width=1100>
<br>
<img src="/files/Pastedimage20240116151656.png" width=1100> 
<br>
<img src="/files/Pastedimage20240116151712.png" width=1100> 
</details>

Пример кода:
```python
def set_tiles(hashMap,_files=None,_data=None):  
    small_tile = {  
        "type": "LinearLayout",  
        "orientation": "vertical",  
        "height": "match_parent",  
        "width": "match_parent",  
        "weight": "0",  
        "Elements": [  
            {  
                "type": "TextView",  
                "show_by_condition": "",  
                "Value": "@room",  
                "NoRefresh": False,  
                "document_type": "",  
                "mask": "",  
                "Variable": "",  
                "TextSize": "15",  
                "TextColor": "#FFFFFF",  
                "TextBold": True,  
                "TextItalic": False,  
                "BackgroundColor": "",  
                "width": "match_parent",  
                "height": "wrap_content",  
                "weight": 0,  
                "gravity_horizontal": "center"  
            },  
            {  
                "type": "LinearLayout",  
                "orientation": "horizontal",  
                "height": "wrap_content",  
                "width": "match_parent",  
                "weight": "1",  
                "Elements": [  
                    {  
                        "type": "TextView",  
                        "show_by_condition": "",  
                        "Value": "Текущая",  
                        "NoRefresh": False,  
                        "document_type": "",  
                        "mask": "",  
                        "Variable": "",  
                        "TextSize": "0",  
                        "TextColor": "#ffffff",  
                        "TextBold": False,  
                        "TextItalic": False,  
                        "BackgroundColor": "",  
                        "width": "wrap_content",  
                        "height": "wrap_content",  
                        "weight": 0  
                    },  
                    {  
                        "type": "TextView",  
                        "show_by_condition": "",  
                        "Value": "@temp",  
                        "NoRefresh": False,  
                        "document_type": "",  
                        "mask": "",  
                        "Variable": "",  
                        "TextSize": "0",  
                        "TextColor": "#ffffff",  
                        "TextBold": False,  
                        "TextItalic": False,  
                        "BackgroundColor": "",  
                        "width": "wrap_content",  
                        "height": "wrap_content",  
                        "weight": 0  
                    }  
                ]  
            },  
            {  
                "type": "LinearLayout",  
                "orientation": "horizontal",  
                "height": "wrap_content",  
                "width": "match_parent",  
                "weight": "1",  
                "Elements": [  
                    {  
                        "type": "TextView",  
                        "show_by_condition": "",  
                        "Value": "Диапазон",  
                        "NoRefresh": False,  
                        "document_type": "",  
                        "mask": "",  
                        "Variable": "",  
                        "TextSize": "0",  
                        "TextColor": "#ffffff",  
                        "TextBold": False,  
                        "TextItalic": False,  
                        "BackgroundColor": "",  
                        "width": "wrap_content",  
                        "height": "wrap_content",  
                        "weight": 0  
                    },  
                    {  
                        "type": "TextView",  
                        "show_by_condition": "",  
                        "Value": "@rate",  
                        "NoRefresh": False,  
                        "document_type": "",  
                        "mask": "",  
                        "Variable": "",  
                        "TextSize": "0",  
                        "TextColor": "#ffffff",  
                        "TextBold": False,  
                        "TextItalic": False,  
                        "BackgroundColor": "",  
                        "width": "wrap_content",  
                        "height": "wrap_content",  
                        "weight": 0  
                    }  
                ]  
            },  
            {  
                "type": "TextView",  
                "show_by_condition": "",  
                "Value": "@port",  
                "NoRefresh": False,  
                "document_type": "",  
                "mask": "",  
                "Variable": "",  
                "TextSize": "-1",  
                "TextColor": "#ffffff",  
                "TextBold": True,  
                "TextItalic": False,  
                "BackgroundColor": "",  
                "width": "match_parent",  
                "height": "wrap_content",  
                "weight": 0  
            }  
        ]  
    }  
  
    tile = {  
        "tiles": [  
            [  
                {  
                    "layout": small_tile,  
                    "data": {  
                        "room": "котельная",  
                        "temp": "23°C",  
                        "rate": "11°C...28°C",  
                        "port": "N1"  
                    },  
                    "color": "#78002e",  
                    "start_screen": "",  
                    "start_process": "Процесс 1"  
                },  
                {  
                    "layout": small_tile,  
                    "data": {  
                        "room": "водоподготовка",  
                        "temp": "24°C",  
                        "rate": "11°C...29°C",  
                        "port": "N1"  
                    },  
                    "color": "#78002e",  
                    "start_screen": "",  
                    "start_process": "Процесс 2"  
                }  
            ],  
            [  
                {  
                    "layout": small_tile,  
                    "data": {  
                        "room": "котельная #2",  
                        "temp": "23°C",  
                        "rate": "10°C...22°C",  
                        "port": "N2"  
                    },  
                    "color": "#e53935",  
                    "start_screen": "",  
                    "start_process": "Процесс 2"  
                },  
                {  
                    "layout": small_tile,  
                    "data": {  
                        "room": "станция ВЭО",  
                        "temp": "норма",  
                        "rate": "",  
                        "port": ""  
                    },  
                    "color": "#78002e",  
                    "start_screen": "",  
                    "start_process": "Процесс 1"  
                }  
            ],  
        ],  
        "background_color": "#f5f5f5"  
    }  
  
    hashMap.put("tiles",
			    json.dumps(tile, ensure_ascii=False)
			    .encode('utf8').decode())  
  
    return hashMap

```

# Корзина
Корзина - это организация списка в виде карточек (не в виде таблицы) с обработкой изменения количества и удаления, как в приложениях интернет-магазинов. Корзину можно использовать для заказов, Scan&Go розницы и много чего еще. Ввиду ограничений ОС, в контейнерах корзина не доступна - она может занимать только весь экран. Поэтому ее следует разместить на экране без контейнера.

Корзина состоит из карточек и итогов внизу. В карточках доступно изменение количества дискретно и удаление. Эти действия обрабатываются на устройстве - пересчитываются итоги, меняется список + возникает событие которые можно обработать онлайн.

Карточки могут содержать 1 картинку либо, если ее нет то ее место сдвигается и остаются поля. Полей может быть сколько угодно. Они состоят из пар «Заголовок»-«Значение», но заголовка опять же может не быть. При этом можно менять размер и цвет текста, а в самих полях писать HTML-текст.
Принцип работы с корзиной такой: структура корзины - это карточки и итоги. Карточки - это JSON - массив. Сначала например можно описать пустую корзину, это будет пустой массив, а также описанный формат итогов. В итогах задается:
> - заголовки итогов
> - по каким переменным карточек их считать (у карточки есть видимые поля, а есть невидимые - они нужны например для дальнейшей обработки состава корзины и для подсчета итогов) а также формат текста и округление

```json
{
"cart": [],
"totals": [
  {
    "caption": "Итого:",
    "var": "sum"
  },
  {
    "caption": "Экономия:",
    "var": "discount"
  }
]
}
```
За формат текста отвечает поле **format** (например «0.0» - один знак после запятой), за цвет и размер **size**, **color** (для значений) и **caption_size**, **caption_color** (для заголовков).
Для добавления в корзину карточек (это можно прописать например при сканировании) в массив «cart» добавляется новый JSON объект. Это карточка. Она может содержать следующие поля:
> - **qty** - количество. Должно быть какое то начальное количество. Например 1
> - **picture** - base64-строка с картинкой. Лучше не слишком большие.
> - **массив items** - массив видимых текстовых данных карточки. Поля key, value - заголовок и текст (причем оба значения необязательны), цвета и размеры **size**, **color** (для значений) и **caption_size**, **caption_color** (для заголовков). Доступен html-текст
> - **массив values** - массив невидимых данных карточки. Тут могут быть числовые поля для того, чтобы рассчитать итоги (они упоминаются в totals) и просто какие то поля для дальнейшей обработки, например ссылка на номенклатуру. Структура JSON объекта не предопределённая - просто любые поля и значения.

# Картинки из кэша
Для повышения быстродействия интерфейса, особенно для повторяющихся элементов, например в карточках, рекомендуется передавать картинки не через base64 а указывать их в конфигурации на странице «Медиаресурсы». Так, картинки передаются вместе с конфигурацией и загружаются на устройство в виде файлов (в папке приложения).
Дальнейшая работа с ними происходит в формате **^имя ресурса** , где имя ресурса вы определяете на странице «Медиаресурсы». Такое обращение доступно везде где есть объект «Картинка» - экраны, карточки и т.д. Также для плиток можно указывать не явную ссылку а ссылку на переменную, а явная ссылка указывается в объекте **data** плитки.
Также использование таких картинок более удобно для структурирования проекта.
Пример структуры:
```json
tiny_tile = {  
    "type": "LinearLayout",  
    "orientation": "vertical",  
    "height": "match_parent",  
    "width": "match_parent",  
    "weight": "0",  
    "Elements": [  
        {  
            "type": "Picture",  
            "show_by_condition": "",  
            "Value": "^kitty",  
            "NoRefresh": False,  
            "document_type": "",  
            "mask": "",  
            "Variable": "",  
            "TextSize": "11",  
            "TextColor": "",  
            "TextBold": False,  
            "TextItalic": False,  
            "BackgroundColor": "",  
            "width": "match_parent",  
            "height": "match_parent",  
            "weight": 1  
        }  
    ]  
}
```
<details>
<summary>Фотогайд</summary>
<br>
<img src="/files/Pastedimage20240116182533.png">
<img src="/files/Pastedimage20240116182851.png"> 
<img src="/files/Pastedimage20240116182743.png"> 
</details>


# Современное поле ввода
**ModernEditText**
Поле ввода, в котором размещается заголовок/подсказка в зависимости от того, заполнено оно или нет. Если в поле присутствует информация, подсказка смещается в область заголовка. Таким образом достаточно размещать только один элемент, что экономит место и упрощает разработку.
Значение задается в виде JSON. Обязательными является hint – подсказка. Например
```json
{
"hint":"Логин",
"default_text":"default_login"
}
```
– задает подсказку, и если поле уже должно содержать данные то они задаются в default_text
По умолчанию – это текстовое поле, но можно задать любой тип имеющийся на Андроиде через input_type. [Варианты](https://developer.android.com/reference/android/text/InputType) 
Также, можно задать counter – счетчик введенных символов внизу и counter_max – максимальное количество символов.
Ключом events можно подключить генерацию событий с каждым введенным символом в поле, чтобы например записывать в БД сразу же введенный текст. Значение должно быть «true»
Например:
```python
def modern_start(hashMap,_files=None,_data=None):  
    modern_json = {  
        "hint": "Пароль",  
        "default_text": "default_password",  
        "counter": "true",  
        "counter_max": 15,  
        "input_type": 145,  
        "password": "true"  
        }  
    hashMap.put("Modern",
				json.dumps(modern_json,
				ensure_ascii=False)
			    .encode('utf8').decode())  
    return hashMap
```
<details>
<summary>Фотогайд</summary>
<br>
<img src="/files/Pastedimage20240116182743.png" width=400>
<img src="/files/Pastedimage20240116164313.png" width=400> 
</details>

# Уведомления и тосты
Команды уведомлений работают из любого контекста вызова, не только на экранах, но и из фона и команд по расписанию.
**toast** - всплывающее внизу экрана уведомление. В качестве параметра просто текст сообщения. Работает в любом контексте. 
```python
if hashMap.get("listener") == "toast_send":  
    hashMap.put("toast", "Вывод toast")
```
![Pastedimage20240117121356.png](/files/Pastedimage20240116182743.png =400x)
**basic_notification** - простое уведомление на экран блокировки c темой и текстом. Работает отовсюду, в том числе из фона. Совместно с сервисом по расписанию можно использовать как замену push. Можно передавать несколько сразу, поэтому в качестве параметра передается JSON-массив, в str формате. Каждое уведомление должно иметь свой номер. По номеру можно обновлять уже выведенные обновления. Например можно вывести уведомление «Началась обработка» с номером 1, а потом послать еще одно уведомление «Обработка завершена» с номером 1 и ОС обновит на экране существующее уведомление если его еще не смахнул пользователь, если его нет – выведет новое. 
Пример:
```python
if hashMap.get("listener") == "basic_send":  
    json_type = [{"number": 2,
			      "title": "Информация",  
                  "message": "Послали basic"}]  
    hashMap.put("basic_notification",f'{json_type}')
```
Тут в JSON зарезервированные слова «number», «title» и «message» - номер, тема и сам текст сообщения.
[![Pastedimage20240117122609.png](/files/Pastedimage20240117122609.png =400x)](/files/Pastedimage20240117122609.png)
**reply_notification** - частный случай обычного уведомления с такими же параметрами запуска, только в уведомлении можно нажать кнопку «Ответить» , ввести текст ответа и отправить его. При ответе сработает специальный обработчик конфигурации на котором можно прописать свою логику. В обработчике доступна переменная reply с текстом, который ввел пользователь. Таким образом можно например отправить текст http-запросом. Этот вид уведомлений поддерживается Android начиная с Oreo.
```python
if hashMap.get("listener") == "reply_send":  
    json_type = [{"number": 1,  
                  "title": "Информация",  
                  "message": "Послали reply"}]  
    hashMap.put("reply_notification",f'{json_type}')
```
[![Pastedimage20240117124406.png](/files/Pastedimage20240117124406.png =400x)](/files/Pastedimage20240117124406.png)

# Модальные экран
## Модальный экран
Можно запустить модальный экран(обычный экран со всем функционалом обычных экранов) для ввода значений с кнопками «ОК» и «Отмена» и перехватывать событие этого экрана. В случае нажатия на ОК будет вызвано событие ввода и переменные этого экрана могут быть обработаны.
Состав экрана вы определяете сами – это обычный экран
Вызов экрана через обработчик – `hashMap.put(«StartScreen», «Имя экрана»)`. Вызываемый экран должен быть в составе процесса.
Получение события через обработчик: переменная event установлена в `“OnResult”`
Запуск экрана Offline: вид действия для запуска «Запустить экран», параметр – **точное** название экрана диалога который есть в составе процесса
Событие ввода : Вид обработчика – «Закрытие экрана», в Обработчике указываете название экрана диалога. 

## Диалог
Модальный диалог в визуальном стиле стандартных диалогов и с возможностью переопределения кнопок и заголовка. Для этого используется команда **ShowDialog** На нем можно разместить свои элементы ввода. С помощью команды:
**ShowDialogLayout**, <JSON-структура контейнера> определяет содержимое окна диалога. Используется совместно с командой ShowDialog
Также можно определить заголовок и название кнопок ОК/Отмена, передав переменную **ShowDialogStyle** 
{"title": "заголовок", "yes": "Да", "no": "Нет"}
Например так:
```python
hashMap.put("ShowDialog", "Диалог ввода");  
hashMap.put("ShowDialogStyle", 
		  '{"title": "Авторизируйтесь",
		    "yes": "Войти", "no": "Отмена"}')  
if hashMap.get("event") == 'onResultPositive':  
	hashMap.put("toast", "Позитив нажали")  
elif hashMap.get("event") == 'onResultNegative':  
	hashMap.put("toast", "Негатив нажали")
```
При этом диалог возвращает события onResultPositive и onResultNegative в зависимости от того, что выбрал пользователь.
[![Pastedimage20240117145932.png](/files/Pastedimage20240117145932.png =400x)](/files/Pastedimage20240117145932.png)
В случае запуска диалога из ActiveCV или сервиса событий, т.е. не обычных процессов, имеющих в своем составе экраны, следует указать переменную **ShowDialogProcess** содержащую имя процесса в котором следует искать экран с контейнером, указанный в ShowDialog либо использовать **ShowDialogLayout**

# Способы входа
## Диалог ПИН-кода
Из процесса или на старте системы можно вывести диалог ПИН-кода. Команда **ShowPIN** с параметром - json-строка. В JSON поля: 
**title** заголовок,
**block_cancel** - запретить закрытие окна (невозможно будет отказаться от ввода ПИН), 
**handlers** - массив обработчиков событий. Проверка ПИН-кода и реакция системы полностью определяется разработчиком на основе событий и введенного пин-кода. Пин-код в случае успешного ввода (успешный - значит введено 4 символа) передается через переменную **pin**. Возможные события:
> - pin_success - пользователь ввел 4 знака, записалась переменная pin
> - pin_cancel - пользователь закрыл окно ввода (в случае такой возможности)

## Проверка отпечатков пальцев и лица
Если устройство поддерживает датчик отпечатка пальца или распознавание лиц, то можно вызвать стандартный диалог проверки биометрических данных. Причем, можно сделать это при запуске (в событии onLaunch), а можно просто запустить из процесса.
Запуск производится командой **ShowBiometric**, с параметром - json-строка. В JSON поля: 
**title** заголовок
**body** - текст
**handlers** - массив обработчиков для отлова событий по биометрии. 
Возможны следующие события (listener):
> - BiometricAuthenticationSucceeded - пользователь успешно прошел проверку
> - BiometricAuthenticationFailed - проверка либо прошла, но неуспешно, либо пользователь закрыл окно аутентификации
> - BiometricAuthenticationError - ошибка создания объекта аутентификации. Скорее всего, функция не поддерживается на устройстве. Дополнительную информация можно прочитать в BiometricError

## Логин и запуск конфигурации
Доступ к настройкам сервиса(экран «Настройки») и перезапуску конфигурации. В Переменные по умолчанию записываются переменные CLIENT_CODE, WS_URL, WS_USER, WS_PASS с настройками онлайн-подключения по умолчанию. Также появился элемент контейнера «Поле ввода пароля». Также появились команды RunLogin или RunSaveLogin - первая просто загружает с настройками - вторая- сохраняет настройки. Этим командам надо передать JSON типа 
```json
{"code": "code",
 "user": "user",
 "password": "pass"}
```
Также в JSON можно передавать «backendURL» и «backendUser»

Для того, чтобы произошла загрузка нужной конфигурации нужно заполнить переменную `ID` кодом справочника Мобильные клиенты, нужного клиента. Это тот же код который указывается в настройках. Если с терминалом будут работать несколько человек, можно создать конфигурацию, содержащую только процесс «Логин» , и другие клиенты будут подгружаться из нее. Также процесс с логином можно добавить во все конфигурации клиентов, в которых нужно перелогироваться (совместное использование одного терминала)