---
title: BasicCommands
description: 
published: true
date: 2024-02-16T12:07:12.781Z
tags: обработчик, экран, диалог, процесс, уведомления, toast, screen, handler, beep, speak, звук, речь, notification, show, event, runpy, функции, getjson
editor: markdown
dateCreated: 2024-01-25T07:43:02.141Z
---

> **[Экраны, диалоги и процессы](/Documentation/BasicСommands/ScreensDialogsProcesses)**
{.is-info}

> **[Запуск процессов из процессов](/Documentation/BasicСommands/ProcessFromProcess)**
{.is-info}

# Основные команды




## Команды управления обработчиками
**RunEvent**, параметр: строка в формате обработчиков - запуск массива любых обработчиков. Т.е. это генерация произвольного события из кода. 
**BreakHandlers** - прерывание выполнения массива обработчиков. Может быть вызвана в каком то обработчике массива (например, проверка ввода) чтобы прервать весь остальной массив 
**BreakHandlersIfError**, без параметра – прерывает дальнейшее выполнение массива обработчиков если в текущем обработчике ошибка

## Уведомления, звуки и речь
Команды уведомлений работают из любого контекста вызова, не только на экранах, но и из фона и команд по расписанию.

[toast](../GeneralFunctionsOfThePlatform/GeneralFunctionsOfThePlatform) - всплывающее внизу экрана уведомление. В качестве параметра просто текст сообщения. Работает везде.
`hashMap.put("toast","Привет мир!")`
[basic_notification](../GeneralFunctionsOfThePlatform/GeneralFunctionsOfThePlatform) - простое уведомление на экран блокировки c темой и текстом. Работает отовсюду, в том числе из фона. Совместно с сервисом по расписанию можно использовать как замену push. Можно передавать несколько сразу, поэтому в качестве параметра передается JSON- массив. Каждое уведомление должно иметь свой номер. По номеру можно обновлять уже выведенные обновления. Например можно вывести уведомление «Началась обработка» с номером 1, а потом послать еще одно уведомление «Обработка завершена» с номером 1 и ОС обновит на экране существующее уведомление еcли его еще не смахнул пользователь, если его нет – выведет новое. Пример запуска уведомления: 
```python
if hashMap.get("listener") == "basic_send":  
    json_type = [{"number": 2,
			      "title": "Информация",  
                  "message": "Послали basic"}]  
    hashMap.put("basic_notification",f'{json_type}')
```
Тут в JSON зарезервированные слова «number», «title» и «message» - номер, тема и сам текст сообщения
[reply_notification](../GeneralFunctionsOfThePlatform/GeneralFunctionsOfThePlatform) - частный случай обычного уведомления с такими же параметрами запуска, только в уведомлении можно нажать кнопку «Ответить» , ввести текст ответа и отправить его. При ответе сработает специальный обработчик конфигурации на котором можно прописать свою логику. В обработчике доступна переменная reply с текстом, который ввел пользователь. Таким образом можно например отправить текст на веб сервис. 
```python
if hashMap.get("listener") == "reply_send":  
    json_type = [{"number": 1,  
                  "title": "Информация",  
                  "message": "Послали reply"}]  
    hashMap.put("reply_notification",f'{json_type}')
```
[beep](../Screens/Screens) - воспроизведение звукового сигнала нужного тона.
Совместно с beep: **beep_volume** - громкость, **beep_duration** - продолжительность в мс.
**vibrate** - вибрация. Можно указывать продолжительность в качестве параметра в мс.
`hashMap.put("vibrate", "1000")` - продолжительность 1 секунда
[speak](../Screens/Screens) - синтез речи из текста, отовсюду в приложении даже из фона и с выключенным экраном. В качестве параметра передается просто текстовая строка которую надо произнести и система ее воспроизводит. 
**listen** - голосовой ввод (распознавание речи) отовсюду, но с оговоркой что в настоящий момент событие ввода будет сгенерировано только если команда запущена из процесса, так как «события ввода» происходят в контексте процессов. В случае контекста приложения (например из обработчика «При открытии») распознанная переменная будет вставлена в обычные или глобальные переменные, но события не будет.

## Динамическое изменение элементов экрана и конфигурации в целом
**getJSONScreen** записывает в переменную **JSONScreen** исходную структуру текущего экрана. 
```Python
hashMap.put("getJSONScreen","")
```
**setJSONScreen** применяет измененную структуру экрана	
**getJSONConfiguration** - считывает в переменную _configuration текущую конфигурацию 
```Python
hashMap.put("getJSONConfiguration","")
```
**setJSONConfiguration** - применяет измененную конфигурацию немедленно.

## Прочие команды Экранов
**RunCV** - запуск режима AciveCV из экрана. После завершения ActiveCV в таком варианте запуска, возникает событие ввода с listener=ActiveCV 
```Python
hashMap.put("RunCV","NameCV")
```
**StartMediaGallery** - запуск выбора файла из галереи мультимедиа, котрый можно инициировать из кода (т.е. определить на свою кнопку например) 
```Python
hashMap.put("StartMediaGallery", "photo_from_camera")
```
**StartCaptureCamera** - запуск камеры 
```Python
hashMap.put("StartCaptureCamera","photo_from_camera")  
```
**SetTitle**, параметра: заголовок экрана - переопределение заголовка экрана 
```Python
hashMap.put("SetTitle","Новый заголовок")
```
**PrintPreview** ,параметр:html-строка - запуск окна с предпросмотром html. Для например, печатных форм, которые из этого окна можно отправить на принтер 
```Python
def test_html_input(hashMap, _files=None, _data=None):
    test_template = Template("""{% for user in users -%}
    <p>Привет, {{ user }}!</p>
    {% endfor %}""")
    res = test_template.render(users=["admin", "Alex", "prog1C"])

    hashMap.put("PrintPreview", res)

    return hashMap
```
[![Pastedimage20240213144851.png](/files/Pastedimage20240213144851.png =350x)](/files/Pastedimage20240213144851.png)
**PrintService** команда запуска PDF-документа на печать встроенной службой печати. В качестве значения нужно передать строку параметров запроса который пойдет на сервер.
```Python
hashMap.put("PrintService","operation=print, barcode=123")
```
Если print не работает - попробуйте view. Это зависит от устройства и софта.
[Подробнее](../ComputerVisionAndAugmentedRealityActiveCV/ComputerVisionAndAugmentedRealityActiveCV)

## Прочие функции, запускаемые из фонового сервиса или общих обработчиков
**ShowProcessScreen**, параметр: {"process": "process", "screen": "screen"} - запуск любого экрана любого процесса из любого состояния приложения (в случае если основной контекст приложения запущен) 
```Python
hashMap.put("ShowProcessScreen", "{'process': 'Некий процесс','screen': 'Экран 1'}")
```
**SpeechRecognitionListener**, в качестве значения можно указать количество миллисекунд отсрочки. Дело в том, что обычно запуск ввода осуществляется после озвучки голосом какого то вопроса, а эта звучка может длится какое то время, причем асинхронно. Поэтому надо примерно поставить время отсрочки пока ваш вопрос звучит, чтобы прослушивание не запустилось раньше
В случае успешного распознавания генерируется событие ввода **voice_success** и в переменную **voice_result** возвращается результат
**SendIntent** - отправка из фона некоего события ввода, на которое подписаны экраны и ActiveCV (там возникает событие ввода) 
**BackgroundCommand** - команда, которой можно передать управление в фоновый Сервис событий и запустить там какой то обработчик

## Команды Python
**RunPy** - запускает синхронное выполнение скрипта Python в UI-потоке приложения. В качестве параметра передается скрипт в виде Base64-строки. Устаревшее, рекомендуется использовать запуск массива обработчиков. 
**RunPyThreadDef** - запускает асинхронное фоновое выполнение скрипта Python. В качестве параметра передается имя функции 
**RunPyThreadProgressDef** - аналогично команде **RunPyThread** , но запускает прогресс-бар, который блокирует UI-поток. В качестве аргумента - имя функции.

