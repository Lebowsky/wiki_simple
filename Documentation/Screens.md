---
title: Screens
description: 
published: true
date: 2024-02-16T10:15:52.276Z
tags: обработчик, экран, screen, handler, beep, звук, речь, сканер, изображения, elements, видимость элементов, штрихкод, таймер, файлы, awesome-шрифт, плавающие кнопки, voice, контейнеры, авторизация
editor: markdown
dateCreated: 2024-01-25T07:43:52.851Z
---

> **[Параметры экрана в конструкторе](/Documentation/Screens/ScreenSettings)**
{.is-info}

> **[Перирисовка экранов](/Documentation/Screens/RedrawingScreens)**
{.is-info}

> **[Кастомизация интерфейса](/Documentation/Screens/CustomizationInterface)**
{.is-info}

> **[Общие элементы экранов](/Documentation/Screens/CommonScreenElements)**
{.is-info}

> **[Прочие элементы интерфейса](/Documentation/Screens/OtherInterfaceElements)**
{.is-info}



# Параметры экрана в конструкторе
## Common 
[![Pastedimage20240202110741.png](/files/Pastedimage20240202110741.png =750x)](/files/Pastedimage20240202110741.png)

- Name - имя экрана, к которому мы можем обращаться, например через 
`hashMap.put("ShowScreen", "Новый экран")` - смена экрана на необходимый нам
- Screen handler on timer - Таймер экрана по расписанию
- Hide top bar - Скрывает верхнюю панель на экране (где находится имя)
- Hide button bar - Отключает клавиши управления снизу экрана
- Disable scrolling for Root Layout - Отключение прокрутки корневого контейнера. Контейнер по умолчанию может вместить неограниченное количество элементов т.е. имеет прокрутку содержимого. Но в случае если в нем располагаются элементы, содержащие прокрутку, например таблица или список карточек это ставит систему в неразрешимое противоречие. Таблицу можно разместить в таком контейнере но она не будет иметь собственную прокрутку содержимого, а будет пролистываться с другими элементами. Если нужно разместить элемент с прокруткой и чтобы она работала(а сам элемент не сдвигался) нужно в экране поставить галочку **Отключить прокрутку для корневого контейнера**
- Attach a keyboard handler - Подключить обработчик клавиатуры
- Close without confirmation - Выход из экрана без вопроса, требующего подтверждения

## Handlers
- OnStart - Событие которое происходит при открытии экрана, так же важно понимать, что после каждого события OnInput, следует событие OnStart автоматически, если явно не отключить это с помощью команды `hashMap.put("noRefresh", "")`
- OnInput - Событие ввода, которое обычно происходит при каком-то действии со стороны пользователя клик на кнопку/карточку/картинку

### Python в обработчиках
Приложения Simple UI могут использовать интерпретатор Python для выполнения кода обработчиков в любом режиме. Можно писать код обработчиков используя процедуры, классы, библиотеки.
Кроме того предусмотрены отдельные общие виды обработчиков:
- При запуске конфигурации
- По расписанию - общий обработчик (периодичность задается в настройках). Запускается в сервисе, работает при неактивном приложении.
- По настраиваемому расписанию - обработчики на закладке «Произвольные таймеры». Можно добавить любое количество обработчиков по расписанию с периодичностью от 1 мс.
- Обработчик ответа в уведомлении
- Обработчик фонового сервиса


Можно разместить там свои функции и потом использовать их через `import ui_general`

Код можно запускать из кода - синхронно (в UI-потоке) и асинхронно (в фоне). Код надо передавать в виде строк Base64:
- RunPy - запускает синхронное выполнение скрипта Python в UI-потоке приложения. В качестве параметра передается скрипт в виде Base64-строки
- RunPyThread - запускает асинхронное фоновое выполнение скрипта Python. В качестве параметра передается скрипт в виде Base64-строки

Код обработчиков взаимодействует с данными и интерфейсов Simple UI через:
- Переменные (локальные и глобальные переменные, команды в переменных как обычно)
- Прямые запросы SQL в СУБД приложения

Взаимодействии с переменными:
- Записать в Переменные : hashMap.put(“имя переменной”, значение переменной)
- Прочитать из переменных: hashMap.get(“имя переменной”)

Пример кода обработчика на Python:
```python
import json
import requests

request = requests.get('http://test.ru')
jdata = json.loads(r.text)
#Записываем в Переменные
hashMap.put("text_info", jdata)
```

## Elements
[![Pastedimage20240202125533.png](/files/Pastedimage20240202125533.png =650x)](/files/Pastedimage20240202125533.png)
В элементы мы может добавить множество объектов, большинство из них описано в других статьях, поэтому долго на них не будем заострять внимание. А пройдемся по всем коротко
- Cart - Корзина, подробнее [тут](../GeneralFunctionsOfThePlatform/GeneralFunctionsOfThePlatform)
- Tiles - Плитки, подробнее [тут](../GeneralFunctionsOfThePlatform/GeneralFunctionsOfThePlatform)
- HorizontalGaleery - Горизонтальная галерея мультимедиа, подробнее дальше по статье
- Photo - Значок для открытия камеры
- barcode - Открытие сканера штрихкодов
- Voice - Открытие сканера голоса
- Signature - Подпись
- LinearLayout - Контейнер, куда можно добавить множество различных элементов
- PhotoGallery - Фото из галереи

# Перирисовка экранов
## Отрисовка переменных на экране в синхронном и асинхронном режиме
 Важно понимать, что событие onStart и отрисовка переменных через @ возникает при обычном запуске пользователем либо выполнении команды ShowScreen – т.е. синхронном выполнении открытия экрана в UI-потоке. Но кроме этого любой обработчик может быть выполнен в асинхронном режиме. Поэтому когда асинхронный обработчик заканчивается, он заканчивается в фоне и ничего не происходит – экран не перерисовывается. Чтобы перерисовать экран и вывести результаты работы асинхронного обработчика есть команда _RefreshScreen_
```Python
hashMap.put("RefreshScreen", "")
```

## Отключение перерисовки документов
Команда noRefresh, отключает перерисовку элементов - т.е. обновление экрана при выполнении обработчика. Пример:
```Python
hashMap.put("noRefresh", "")
```
Отключает вызов onstart после oninput, лучше класть в oninput, автоматически удаляется после единичного срабатывания

# Кастомизация интерфейса
Имеется возможность кастомизировать элементы так как вам хочется, для получения любого элемента интерфейса, выведенного на экране, включая контейнеры используется симпловский метод getView("ИД"), где ИД - переменная элемента. Для изменения элемента используется библиотека [GradientDrawable](https://developer.android.com/reference/android/graphics/drawable/GradientDrawable)
```Python
def tst_input(hashMap,_files=None,_data=None):
    from ru.travelfood.simple_ui import ImportUtils as iuClass
    from android.graphics.drawable import GradientDrawable
    from android.graphics import Color
    

    v = iuClass.getView("btn_tst")
    v.setTextColor(-65536)

    shape =  GradientDrawable()
    shape.setShape(GradientDrawable.OVAL)
    shape.setColor(Color.WHITE)
    shape.setStroke(40, Color.WHITE)


    v.setBackground(shape)

    hashMap.put("noRefresh","")
    
    return hashMap 
```
[![Pastedimage20240212152034.png](/files/Pastedimage20240212152034.png =300x)](/files/Pastedimage20240212152034.png)
# Общие элементы экранов
## Сканирование штрихкода
Если на экране требуется распознавание штрихкода, то необходимо добавить на экран элемент «Штрих-код» и указать переменную(variable), которую будет воспринимать hashMap, в которую он будет записываться по факту сканирования.
<details>
<summary>Фотогайд</summary>
<br>
<img src="/files/Pastedimage20240112172533.png" width=700>
<br>
<img src="/files/Pastedimage20240112172558.png" width=700> 
<br>
<img src="/files/Pastedimage20240112172746.png" width=700> 
</details>

Если на устройстве есть аппаратный сканер, желательно указать галочку «Аппаратный сканер» в настройках. В противном случае на экране будет присутствовать кнопка сканирования через камеру устройства. Соответственно, при сканировании через камеру при добавлении элемента Штрих-код подразумевается что будет нажиматься парящая кнопка. Также в настройках можно включить подсветку. Также при использовании Bluetooth сканеров в режиме SSP сопряжения необходимо активировать Использовать Bluetooth и выбрать устройство и суффикс (это все обычно программируется на устройстве штрих-кодами из инструкции). Bluetooth сканеры обычно могут работать и в режиме HID но в таком случае на экране нельзя размещать другие элементы ввода – они будут перехватывать строку. Аппаратный сканер ТСД может быть запрограммирован в режиме HID (в разрыв клавиатуры) с суффиксом CR/LF на конце. Либо он может быть запрограммирован на передачу сообщения через подписку на intent. Второй вариант лучше, потому что поля ввода не перехватывают такое сообщение и можно располагать ввод штрихкода с полями ввода на одном экране. Для использования в этом режиме надо включить галку «Использовать подписку на события сканера» и заполнить поля. Заполнение полей индивидульно для разных моделей, информацию ищите в документации либо в ПО ТСД.
[![Pastedimage20240112173214.png](/files/Pastedimage20240112172746.png =700x)](/files/Pastedimage20240112172746.png)
Знак сканирования через камеру

## Передача картинки
На экране может быть выведена картинка на том месте где находится элемент picture. Картинка передается через обычную переменную в виде строки Base64.
```python
def screen_on_start(hashMap):
    hashMap.put("picture", base64_cod_picture)  
    return hashMap
```

<details>
<summary>Фотогайд</summary>
<br>
<img src="/files/Pastedimage20240112183031.png" width=700>
<br>
<img src="/files/Pastedimage20240112182924.png" width=400>   
</details>

## Прием картинки с камеры
В составе экрана можно разместить элемент «Фото с камеры» , тогда на экране появится кнопка камеры. И это изображение можно передавать в переменную base64 либо выдавать ссылку на файл (с флагом mm_local).

## Горизонтальная галерея мультимедиа
Элемент управления «Горизонтальная галерея мультимедиа» это и визуальный и активный элемент, который позволяет упростить работу с изображениями. Он предназначен для визуализации в виде миниатюр массива мультимедиа. Входная переменная - это JSON массив либо идентификаторов файлов (в случае флага mm_local) типа [id1, id2] и т.д. либо JSON массив вида 
```json
[{  
    "uid": id1,  
    "base64": "данные картинки 1"},  
{  
    "uid": id2,  
    "base64": "данные картинки 2"}]
```
то есть массив, содержащий непосредственно данные. Сам массив формируется когда добавляются мультимедиа с камеры или из галереи, либо удаляются. То есть для функционирования достаточно разместить элемент галереи и «Фото с камеры» или «Фото с галереи» и указать любую переменную. При работе с мультимедиа или удалении будут возникать события ввода, при которых переменную с массивом можно например сохранить. Удобнее всего это делать в режиме NoSQL (именно так устроены примеры в демо-базе). Причем даже если хранение у вас на SQL все разно сами фото можно хранить в объектах NoSQL и ссылаться на них. Для удаление нужно пометить миниатюры долгим тапом.
<details>
<summary>Фотогайд</summary>
<br>
<img src="/files/Pastedimage20240115103710.png" width=700>
<br>
<img src="/files/Pastedimage20240115103735.png" width=700>  
<br> 
<img src="/files/Pastedimage20240115104401.png" width=400>   
</details>

## Таймер экрана
На экране можно определить таймер, который будет периодически генерировать событие ввода (частота таймера задается в общих настройках). Данная функция была введена до того, как в платформе появились асинхронные обработчики. Большинство сценариев для которых нужен таймер гораздо более эффективно реализуются на асинхроне и системе не нужно постоянно дергать экран, более того это еще и более быстрая реакция. Поэтому прежде чем использовать таймер, рекомендуется посмотреть в сторону асинхронных вызовов экранов или сервиса событий
### Запуска таймеров из кода

Таймеры (повторяющиеся в фоне задания) можно определить в конфигурации и также в новом релизе запустить/остановить из кода.
- **StartTimers** , пустой параметр – инициализирует объект таймеров 
- **StartTimer**, `{"handler": "массив обработчиков", "period": "периодичность, мс"}` - добавляет новый таймер и запускает его 
- **StopTimers**, пустой параметр – останавливает объект таймеров и удаляет все ранее добавленные таймеры (командой StartTimer)

[![Pastedimage20240122162641.png](/files/Pastedimage20240122162641.png =700x)](/files/Pastedimage20240122162641.png)


## Сообщение об ошибке
В режиме онлайн заполнение переменной Сообщение об ошибке (ErrorMessage) вызывает показ надписи с текстом ошибки внизу экрана. Прерывание по exception в других обработчиках таже вызывает показ ошибки внизу экрана
```Python
hashMap.put("ErrorMessage", "Ошибка")
```

## Видимость элементов
Для управления видимостью отдельных элементов экрана следует использовать команду Show_<Идентификатор элемента>
```Python
hashMap.put("Show_element", -1)
```
element - переменная элемента (переменная=идентификатор).
Значения могут быть: 
- 1 виден , 
- 0 не виден, без освобождения места, 
- -1 не виден, с освобождением места

## Режим работы с мультимедиа и файлами по ссылкам (флаг mm_local)
Можно хранить мультимедиа и галереи в виде base64-строки, но это довольно ресурсозатратный процесс. Вследствие того что кодирование и раскодирование занимает время и место, обычно при таком подходе мультимедиа сильно сжимают и по размеру и по компрессии. Альтернатива этому новый режим который задействуется переменной **mm_local**
```Python
hashMap.put("mm_local", "")
```
При таком режиме файлы хранятся на диске, а в Переменных хранятся только их идентификаторы. Т.е. при попадании новой например картинки в устройство он сохраняется на диске, взамен выдается идентификатор, далее операции производятся с идентификатором а когда нужно отправить эту картинку по синхронизации по идентификатору можно получить сам файл. Имя файла совпадает с идентификатором. Файлы хранятся во внутреннем хранилище приложения. Имя файла - сгенерированный uid. картинки можно не сжимать при таком подходе но все равно есть возможность сжимать. Для этого используются флаги **mm_compression** и **mm_size** где в качестве параметра указывается процент от 100% реального размера и 100% качества.
`hashMap.put("mm_compression", "70")` - это будет компрессия 70%. 
`hashMap.put("mm_size", "50")` - это будет размер 50%
Использование этих 3х флагов очень простое - если флаги объявлены на экране (в «При открытии» например) то активные элементы (добавление фото, галерея и т.д.) ведут себя соответствующе - возвращают не base64 а ссылки на файлы. 
Файлы, генерируемые на устройстве, это в том числе изображения с камеры или медиагалереи устройства, загружаемые с ключом mm_local. У подобных файлов при сохранении генерируется uuid, по которому к нему можно обратиться. Этот uuid равен имени файла. Можно просто работать с именем файла, запоминая его в своих структурах данных. Например при фотографировании в режиме mm_local в переменную (допустим переменная камеры называется photo) сохраняется абсолютный путь с приставкой _path, то есть в данном случае будет переменная photo_path.
```python
if hashMap.get("listener") == "photo":  
    hashMap.put("toast", hashMap.get("photo_path"))
```
Вывод toast с путем к файлу
Сами ссылки хранятся в СУБД на устройстве в виде пар «идентификатор-путь к файлу» и могут быть получены в любой момент командой «getfiles» 
```Python
hashMap.put("getfiles", "")
```
и выданы в событии «_results» в переменную «_files». То есть всегда можно узнать абсолютный путь к файлу, получить файл и сделать с ним что угодно. Например наложить фильтры, удалить и т.д. Кроме того при синхронизации (при входящих файлах) следует также использовать специальную команду «addfile_идентификатор, путь к файлу» для того чтобы записать в массив _files идентификатор и путь.

## Режим работы с файлами изображений напрямую по абсолютному пути (через ~)
Во всех визуальных элементах (картинка на форме, картинка в карточке, в диалоге, в плитке и т.д.) возможно указание непосредственно файла на диске. Этот подход обеспечивает гораздо более высокую производительность нежели работа через base64. Особенно это заметно в больших списках где используется много изображений. Для передачи в переменную картинки следует использовать путь к файлу в файловой системе устройства с префиксом ~. Абсолютные пути к файлам могут быть доставлены в переменную _files командой getfiles, а также для обработчиков на python доступна коллекция _files через которую можно получить, записать файл по uid.
Также для отправки файлов используются фоновые команды (выполняют обмен в фоне, не блокируя ui-поток):
(post_file_УИДфайла, url) , где УИДфайла - уид картинки, url – ссылка на POST команду HTTP сервера на который отправится картинка. 
Например: 
```Python
hashMap.put("post_file_"+str(ID), http://...)
```
(post_file_array_ПерменнаяМассив, url), где ПерменнаяМассив – переменная такая, которая используется для галереи, т.е. если например на экране расположена галерея то дополнительно ничего делать не надо можно просто написать 
```Python
hashMap.put("post_file_array_photoArray", "http://...")
```

## Awesome-шрифт
Это набор пиктограмм, с помощью которого можно сделать свои красивые кнопки, сделать иконки на карточках, экранах и т.д.
Используется бесплатный набор из 1001 иконки [https://fontawesome.com/v5.15/icons?d=gallery&p=2&s=solid&m=free](https://fontawesome.com/v5.15/icons?d=gallery&p=2&s=solid&m=free) Для того чтобы использовать, надо взять на сайте Unicode -код например f6be и присвоить переменной с префиксом # – т.е. #f6be, который потом указать в заголовке кнопки или надписи. Это можно использовать в элементах экранов, диалогов и т.д.:

- Кнопка
- Список кнопок
- Горизонтальный список кнопок
- Надпись

<details>
<summary>Фотогайд</summary>
<br>
<img src="/files/Pastedimage20240115122642.png" width=850>
<br>
<img src="/files/Pastedimage20240115122700.png" width=400>      
</details>

## Плавающие кнопки
В ряду стандартных кнопок экрана можно добавлять свои кнопки (элемент «Плавающая кнопка»). Можно использовать стандартную иконку (выбрать из Иконка), либо установить через «#» [Awesome- иконку](Awesome-font.md), аналогично тому, как это сделано в других случаях. В этом случае возможно потребуется дополнительно отцентрировать иконку, для этого после надписи можно указать смещение по горизонтали и вертикали. Например: (#f1d8;1;-20)
[![Pastedimage20240122162137.png](/files/Pastedimage20240115122700.png =400x)](/files/Pastedimage20240115122700.png)

# Прочие элементы интерфейса
## Звуковой сигнал
Можно воспроизвести «бип» - один из 100, заложенный в Андроиде, если присвоить в переменную `beep` значение от 1 до 99, либо оставить пустой - тогда будет звук по умолчанию. 
```Python
hashMap.put("beep", "")
```
Это работает и в онлайн и в оффлайн (через присвоение переменных). Примеры звуков:[https://developer.android.com/reference/android/media/ToneGenerator#TONE_CDMA_ABBR_REORDER](https://developer.android.com/reference/android/media/ToneGenerator#TONE_CDMA_ABBR_REORDER)

## Синтез речи
Можно воспроизводить речь, используя команду-переменную **speak** , например
```Python
hashMap.put("speak", "Привет, мир!")`
```
Данная команда работает как в контексте экранов так и в контексте фонового Сервиса событий

## Распознавание речи
На экране можно размесить элемент Голос, с переменной, в которую будет записываться распознанная строка. По нажатию на кнопку запускается распознавание, когда вы закончите говорить возвращается результат - событие экрана с listener="voice" и результат распознавания в переменной.
```python
if hashMap.get("listener") == "voice":  
    result_voice = hashMap.get('voice')  
    hashMap.put("result_voice", result_voice)
```
Также, можно организовать работу с речью вне экрана (в фоновом Сервисе событий) и например запускать распознавание речи не по кнопке а из кода, командой voice (в случае использования сервиса, результат будет возвращаться в Общие события, на него можно подписаться). В команде voice можно определить период ожидания пользователя. Таким образом команды [[SpeechSynthesis|speak]] и voice могут быть использованы для сборки голосового ассистента поверх всей системы, но взаимодействующего с логикой приложения и с экранами и общими функциями (из Сервиса событий можно взаимодействовать с экранами)
<details>
<summary>Фотогайд</summary>
<br>
<img src="/files/Pastedimage20240115144953.png" width=700>
<br>
<img src="/files/Pastedimage20240115145011.png" width=700> 
<br>     
<img src="/files/Pastedimage20240115145105.png" width=400>  
<img src="/files/Pastedimage20240115145852.png" width=400>    
</details>

## Контейнеры
Контейнер по умолчанию может вместить неограниченное количество элементов т.е. имеет прокрутку содержимого. Но в случае если в нем располагаются элементы, содержащие прокрутку, например таблица или список карточек это ставит систему в неразрешимое противоречие. Таблицу можно разместить в таком контейнере но она не будет иметь собственную прокрутку содержимого а будет пролистываться с другими элементами. Если нужно разместить эелемент с прокруткой и чтобы она работала(а сам элемент не сдвигался) нужно в экране поставить галочку Отключить прокрутку для корневого контейнера
### Элементы контейнера
Контейнеры включают в себя собственные визуальные элементы. При этом невизуальные – Голос, ШтрихКод и т.д. могут быть в экране помимо корневого контейнера и использоваться. Обработка переменных происходит в обработчиках экранов. Сколько бы не было вложенных контейнеров все обработчики – в экране. Элементы контейнера отличаются следующими свойствами:
- Их может быть неограниченное количество каждого типа
- На каждый из них может быть задано собственное оформление
- Для кнопок есть галочка «Не обновлять экран» - происходит только отправка запроса или выполнение офлайн обработчика. Перерисовка не происходит
- Для полей ввода можно задавать предопределенные значения
- Можно задавать оформление элементов непосредственно в элементах, контейнарах, а можно исопльзовать справочние Элементы стилей, как шаблон. Т.е. создать справочник, а потом использовтаь его для заполнения настроек оформления в экранах

Оформление включат в себя элементы «Высота», «Ширина» и «Вес» - они полностью аналогичны контейнерам. Т.е. например если поставить у кнопки ширину и высоту «На весь контейнер» то она займет весь контейнер. Также элементы оформления Цвет фона, цвет текста – установка цветов в HEX кодировке вместе с символом #. Посмотреть палитру можно в интернете. Андроид рекомендует использовать «материал» цвета например с ними удобно работать вот [тут](https://materialuicolors.co/).Можно копировать и вставлять в поля. Размер текста – числовой размер текста Выравнивание – Лево, Право, Центр. Выравнивание зависит от ширины и высоты. Например если надпись в контейнере котрый «По размеру элементов» по ширине, то от установки выранивания «По центру» ничего не изменится. Но если вам надо расположить надпись по центру экрана – вам надо сделать размер контейнера «На весь контейнер» по ширине и поставить Выравнивание «По центру» Иконка – выбор из нескольких иконок для кнопок.

Виды элементов контейнера:
- Контейнер – вложенный контейнер
- Картинка – картинка в виде строки base 64. Работа аналогична картинкам обычного экрана
- Диаграмма – диаграмма типа «Круговая», «Столбики» и «Линейная». Установка столбцовой и линейной диаграммы возможна по сериям. Установка значений производится путем передачи json строки.
- Индикатор – индикатор со своей шкалой. Возможна установка минимального и максимального значения, границ красной, желтой и зеленой зон и самого значения. Установка происходит через передачу json строки.
- Список – простой выпадающий список. Элементы можно задать в виде строки с разделителем «;» через переменную или прямо в кострукторе. В списке всегда будет выбран первый элемент, поэтому если требуется чтобы по умолчанию было пусто , первым элементом следует определить пустую строку или что то подобное. Например: ("Выберите значение";Первый;Второй). В «Переменную» при этом возвращается выбранное значение. Можно указать значение по умолчанию - то значение которое будет выбрано при открытии. Для этого нужно в стек переменных поместить переменную с именем переменной результата.Например, если перменная - res то помещаем в 
```Python
hashMap.put("res", "Второй")
```
- Таблица – таблица на экране. Может быть несколько таблиц расположенных как угодно.
- Список карточек – прокручиваемый список карточек
- Плитки – прокручиваемый список карточек (см. также «[Плитки и плиточное главное меню](../GeneralFunctionsOfThePlatform/GeneralFunctionsOfThePlatform)»)
- Надпись – их может быть сколько угодно с любым оформлением
- Кнопка – в отличии от «упрощенного режима» кнопки не располагаются в блоках а добавляются по одной и каждая вызывает событие при нажатии.
- Поле ввода число и Поле ввода строка – может быть произвольное количество полей. В отличии от упрощенного режима «Поле ввода» не имеет заголовка. Если нужен заголовок – то рядом нужно поместить «Надпись» В «Заполнение поля» можно поместить значение или переменную для начального заполнения
- Поле ввода пароля - поле ввода со скрытым текстом
- Современное поле ввода - настраиваемое поле ввода (см. «[Современное поле ввода](../GeneralFunctionsOfThePlatform/GeneralFunctionsOfThePlatform)»)
- Поле ввода автозаполнение списка - поле ввода с автозаполнением. В «Заполнение поля» надо передать переменную, содержащую список возможных вариантов разделенный «;». В остальном обычное поле ввода.
- Поле ввода с событием - обычное текстовое поле,но генерирующее событие ввода при каждом набранном символе. Можно исопльзовать для обновления таблицы на экране, зависимой от ввода например.
- Флажок – логическое значение. В Переменные записывается “true”/”false” - именно в строковом виде.

## Функции авторизации и загрузки конфигурации
Можно организовать экран входа в систему который будет запускаться при запуске приложения и пункт основного меню для перелогирования. Для того чтобы процесс запускался при входе в приложение нужно поставить галочку «Запустить при старте» Есть функции логина - доступ к настройкам сервиса(экран «Настройки») и перезапуску конфигурации. В Переменные по умолчанию записываются переменные CLIENT_CODE, WS_URL, WS_USER, WS_PASS с настройками онлайн-подключения по умолчанию. Также появился элемент контейнера «Поле ввода пароля». Также команды RunLogin или RunSaveLogin - первая просто загружает с настройками, вторая - сохраняет настройки. Этим командам надо передать JSON типа 
```json
{"code": "code",
 "user": "user",
 "password": "pass"}
```
 Также в JSON можно передавать "backendURL" и "backendUser" команда SetSettingsJSON которая загружает любые настройки в виде JSON, как если бы они были переданы через файл или через QR, в т.ч настройки хостинга конфигурации или сам текст конфигурации («configuration») Также есть команды которые позволяют переопределить любой кусок текста конфигурации setJSONConfiguration (а получить предварительно getJSONConfiguration) таким образом можно например включить/выключить некоторые процессы при загрузке. Таким образом на экране логина можно управлять загружаемой конфигурацией или переопределять ее.
 

