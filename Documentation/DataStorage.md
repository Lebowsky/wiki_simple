---
title: DataStorage
description: 
published: true
date: 2024-02-14T08:24:40.485Z
tags: sql, nosql, хранение данных, simplebase, статические ресурсы, изображения, simpleutilites
editor: markdown
dateCreated: 2024-01-25T07:43:19.215Z
---

# SQL
## Основные команды SQL
Стандартным для Android является встроенный SQLite. Его преимущества в том, что это классическая реляционная СУБД – быстрая работа, SQL запросы, агрегирующие функции. Например найти товар по штрихкоду из 1 миллиона записей, да еще по сложному условию -это не сделать быстрее чем на SQL с индексами. Или например посчитать агрегаты – сумму по строкам таблицы. Опять же быстрее SQL с этим никто не справиться.
Можно завести несколько СУБД в рамках приложения.
К SQL можно обращаться из Python напрямую, в т.ч использую ORM но рекомендуется использовать единую точку входа(SQLProvider) либо через команды переменные либо через класс **SimpleSQLProvider** в Python либо через нативные обработчики (они также используют SimpleSQLProvider).Т.е. при обращении к SQL используется Java-класс реализующий монопольное подключение к СУБД и общий поток событий.
Можно работать с SQL через команды-переменные либо(если из питон-обработчиков) использовать вызовы специального класса в явном виде.
Справочник команд-переменных:

>### <kbd>SQLConnectDatabase</kbd>
>```Python
> hashMap.put("SQLConnectDatabase", "test1.DB")
> ```
>Так как указывается имя базы предполагается что можно использовать несколько баз, помимо дефолтной.

>### <kbd>**SQLExec**</kbd>
>```Python
>{"query": "SQL statement", "params": "parameters with delimiter"}
>```
>Например:
>```sql
>sql_query = "CREATE TABLE IF NOT EXISTS Record
>		(id integer primary key autoincrement,
>		 art text,
>		 barcode text, 
>		 name text, 
>		 qty real)"
>```
>```python
>hashMap.put("SQLExec",
>		     json.dumps({"query": sql_query,
>		     "params":""}))
>```
>Выполняет запрос на изменение БД (все кроме SELECT), параметры в запросе указываются в неименованном виде, а в params, перечисляются через запятую

>### <kbd>**SQLExecMany**</kbd>
>```Python
>{"query": "SQL statement", "params": "parameters with delimiter"}
>```
> Выполняет запрос в BULK-режиме с массивом из множества записей. Параметры запроса передаются в виде массива записей в неименованном виде (через ?)
> Пример:
> ```SQL
> sql_query = "INSERT INTO goods(art,barcode,nom) 
> 		   VALUES(?,?,?)"
> ```
> ```python
> values=[]
> for i in range(1,3):
> 	record =[]
> 	record.append("AA"+str(i))
> 	record.append("22"+str(i))
> 	record.append(f"Товар переменной {str(i))}"
> 	values.append(record)
> 
> hashMap.put("SQLExecMany",
>			json.dumps({"query": sql_query,
>			"params": json.dumps(values, ensure_ascii=False)}))
> ```


>### <kbd>**SQLParameter**</kbd>
>Имеет смысл для SQLExecMany для передачи массива записей в качестве параметра из других обработчиков

>### <kbd>**SQLQuery**</kbd>
>```Python
>{"query": "SQL statement","params": "parameters with delimiter"}
>```
> Запрос типа SELECT, который пишет выборку в виде JSON-массива в стек переменных в SQLResult
> Пример query:
>```SQL
>sql_query = "SELECT name FROM sqlite_master WHERE type='table'" 
>```
>Пример запроса:
>```python
>info = requests.post(f"url={our_url}&query={sql_query}&params=",
>			headers={'Content-Type': 'Application/json;charset=utf-8'})
>```
>_

>### <kbd>**SQLQueryMany**</kbd>
>```Python
>{"query": "SQL statement","params": "parameters with delimiter"}
>```
> Запрос типа SELECT, который пишет выборку в виде JSON-массива во временный файл и в параметре SQLResultFile возвращает имя этого файла. Для очень больших выборок (>0.5 млн строк)

Те же функции можно вызывать из импортируемого класса напрямую. Этот вариант хорош тем что результат получаешь сразу а не на конец шага и его лучше использовать в python-обработчиках.

```python
from ru.travelfood.simple_ui import SimpleSQLProvider as sqlClass
sql = sqlClass()
  success=sql.SQLExec("insert into goods(art,barcode,nom) values(?,?,?)","111222,22000332323,Некий товар")
  res = sql.SQLQuery("select * from goods where id=1","")
  if success:
      hashMap.put("toast",res)
```

## Работа с SQL напрямую через конфигурацию
Можно работать с SQL не через команды-переменные и не через Python, а напрямую. Это один из «нативных» обработчиков, работающих через единый провайдер. Данный вид обработчика удобно использовать для простых ситуаций – вытащить переменные из SQL по отбору, записать простой insert или update и т.д. Что например можно делать этим инструментом:

1. Передавать любые поля в запрос из стека переменных через @, также как они передаются на форму например. Например, этот запрос запишет в таблицу name и barcode. Это касается и переменных запроса и условий.
[![Pastedimage20240118124900.png](/files/Pastedimage20240118124900.png =750x)](/files/Pastedimage20240118124900.png)
2. Select распознается как выборка и пишет результат в переменные в виде JSON-массива (такой же как если вызвать это через команду переменные или класс)
[![Pastedimage20240118124653.png](/files/Pastedimage20240118124653.png =750x)](/files/Pastedimage20240118124653.png)
3. Но если в select написать limit 1 то обработчик запишет переменные 1й строки сразу в стек переменных. Удобно например при открытии сделать выборку, сразу получить переменные и привязать их на форму – без парсинга и т.е.
[![Pastedimage20240118124948.png](/files/Pastedimage20240118124948.png =750x)](/files/Pastedimage20240118124948.png)

# NoSQL
Параллельно с **SQL** данные на устройстве можно хранить в NoSQL- СУБД. Этот режим обладает множеством преимуществ, главное из которых - простота разработки. Хранение в NoSQL не исключает хранение в SQL - можно одновременно использовать и то и то.
## SimpleBase
SimpleBase - это открытый проект безсерверной JSON-ориентированной СУБД на Python который встроен в SimpleUI в виде Python-библиотеки и параллельно реализован в apk в виде Java-реализации. В SimpleWEB, соотвественно, просто достаточно подключить библиотеку из pip. 
Документация: [https://simplebase.readthedocs.io/en/latest](https://simplebase.readthedocs.io/en/latest)
GitHub : [https://github.com/dvdocumentation/simplebase](https://github.com/dvdocumentation/simplebase)
Это наиболее простой способ работы с локальным хранением – по сути чистый JSON, для которого не нужно знать SQL, да и вообще на JSON в стеке симпла буквально все команды, разметки экрана и переменных. Например: пришли документы с сервера по http – это JSON, его не надо растаскивать по таблицам а можно хранить как есть, работать с ним как есть, выводить на экран, заполнять экранные списки – JSON, обратно отсылать – то же JSON без собирания и упаковки. Получается это намного проще SQL, а из стека нужно знать только работу со словарями и списками - итерации и вот это вот все. За счет особой архитектуры работы с данными удалось добиться показателей скорости, сравнимых с SQL в критичных участках: добавление данных, поиск по индексу, текстовый поиск. 
Свойства SimpleBase:
> - Мгновенное добавление новых записей в коллекции независимо от размера коллекции благодаря специальной архитектуре хранения.
> - Более быстрая работа с операциями, за счет того, что не требуется кодировать/декодировать всю коллекцию (которая может быть очень большой)
> - Коллекции всегда хранятся в оперативной памяти с отслеживанием изменений одновременно: данные перечитываются с диска только в том случае, если они были изменены другим процессом.
> - ACID для многопользовательской и многопоточной работы
> - Два типа индексов для ключевых типов запросов — хеш-индекс и специальное B-дерево для полнотекстового поиска.
> - Поддержка транзакций (сессий)

### Интеграция SimpleBase на уровне Python-библиотеки
Базы SimpleBase хранятся в специальном каталоге SimpleBase в папке приложения. Базу можно располагать где угодно, но желательно прописывать путь к этой папке, для того, чтобы нативные функции могли работать с этой базой тоже. Для этого есть функция get_simplebase_files в классе SimpleUtilities
Инициализация будет выглядеть так
```python
from pysimplebase import SimpleBase
from ru.travelfood.simple_ui import SimpleUtilites as suClass
db = SimpleBase("test_db", 
				path=suClass.get_simplebase_dir(),
				timeout=200)
```
Вся остальная работа с СУБД согласно документации к SimpleBase

## Старая NoSQL
В NoSQL СУБД данные хранятся в режиме «ключ - значение» а не в таблицах. В любой ключ можно записать любое значение - текст, JSON и т.д. Т.е. работа происходит с неструктурированной информацией. Структуры данных типа документов и справочников удобнее хранить в JSON.
С NoSQL базами можно работать через стек переменных и непосредственно из python– обработчиков. В случае работы через методы класса NoSQL преимуществом является получение результата сразу, также то что просты типы можно использовать как есть, без преобразования в строку.

### Работа с NoSQL ключ-значение  
```Python
Для работы необходимо подключить класс NoSQL и создать объект. Импортировать класс можно двумя способами:

1. from ru.travelfood.simple_ui import NoSQL as noClass

2. from java import jclass
	noClass = jclass("ru.travelfood.simple_ui.NoSQL")`

Далее нужно создать объект, указав в качестве параметра имя существующей или новой БД. Она будет создана при необходимости
 
ncl = noClass("test_new_nosql")` 
```

Методы объекта:
- **put(ключ, значение, регистрировать_в_очереди)** – помещает значение в указанный ключ. Значения типов строка, число, булево – можно помещать как есть. JSON лучше преобразоывать в строку. Пример:
```Python
ncl.put("k1", "Это строка", True)
```
- **get(ключ)** – получает значение по ключу
- **delete(ключ)** – удаляет ключ
- **destroy()** – уничтожает все ключи базы
- **getallkeys()** – получить список всех ключей базы в виде строки формата JSON-массива строк
- **findJSON(поле,значение)** – медленный поиск среди всех объектов базы которые имеют тип JSON , объектов, в **поле** которых есть **значение**. Возвращает строку с JSON-массивом найденных объектов. Лучше использовать в базах, где мало значений, если значений много -лучше испоьзовтаь поиск с индексом.
Пример:
```python
j3 = {"name": "Дарья", 
	  "surname": "Смирнова"}
ncl.put("jk3",json.dumps(j3,ensure_ascii=False),True)

#Поиск без индекса
res = ncl.findJSON("name", "Дарья")
jres = json.loads(str(res).encode("utf-8"))

```

- **run_index** (имя_индекса,поле – создание индекса по JSON-объектам для дальнейшего использования для поиска. Создает, асинхроннно индекс, состоящий из объектов с указанным полем.
- **findJSON_index** (имя_индекса, поле, значение) – поиск по индексу. Возвращает строку с JSON-массивом найденных объектов. Поиск ведется по ключам, в которых записаны JSON-строки объектов.

### Работа с NoSQL ключ-значение через стек переменных (команды-переменные)

Вся работа происходит через Переменные (в Python - hashMap). Например в Переменные передается команда к СУБД и данные, которые надо вставить. Данные, запрошенные из СУБД также возвращаются в Переменные.
В конфигурации можно определить название СУБД в поле «Имя базы noSQL» , чтобы у каждой конфигурации была собственная СУБД, а можно не использовать разделение, например чтобы можно было использовать общие данные.

1)Запись, чтение, удаление:
 - **(put_ключ, переменная)** - записать данные в СУБД в ключ    
 - **(get_ключ, переменная)** - получить данные из СУБД из ключа в переменную. Если в обработчике есть команды get_, find_ и finindex_ система извлекает данные из СУБД в Переменные, после чего вызывает событие «_results» (как бы новый такт обработчика)     
 - **(del_ключ,)** - удалить ключ     
 - **(getallkeys, переменная)** - получить список всех ключей     

2)Поиск и индексы:
 - **(find_имяпеременной, имяполя=значение)** - «условно медленный» поиск по объектам в СУБД. в «имяпеременной» возвращается JSON-массив найденных объектов. «имяполя» - имя поля в корне JSON объектов по которому будет вестись поиск. Вид сравнение можно использовать «=»(точное сравнение) или «~»(вхождение подстроки). Значение - значение поиска.     
 - **(createindex_имяиндекса, имяполя)** и (**findindex_имяиндекса, имяполя=значение**). Индексы - загруженные в память таблицы значение - ключ, по которым происходит более быстрый поиск. Т.е. если индекс задать заранее, поиск будет произвдиться очень быстро - ведь это поиск по массивы у памяти а не в СУБД. Поэтому где в начале, возможно при запуске конфигурации, следует создать нужные индексы командой **createindex_**. Далее использовать команду **findindex_**, где в качестве параметра поиска уже использовать имя ранее созданного индекса.
 
3)Очередь
Очередь используется для автоматической фиксации изменённых или добавленных объектов. Это используется например для синхронизации - всегда можно получить список ключей, измененных на устройстве, чтобы выгрузить в основную систему. Очередь пишется автоматически, но ее можно выключить например при загрузке данных из учетной системы командой («StopQueue»,»»)
 - **_sys_queue** - переменная-очередь, в которой всегда содержится список ключей объектов, разделенных через «;»
 - **(removequeue,ключ)** - удалить ключ из очереди (например, при успешной выгрузке)
 
 # Файлы
 Все файлы хранятся во внутренней папки приложения SimpleUI, которая полностью доступна из самого приложения, но недоступна для других приложений (кроме как через root). С файлами можно выполнять любые операции из обработчиков python - читать содержимое папки, чистать файлы, записывать и т.д. Т.е. например, можно перехватить картинку, сделанную с камеры и выполнить кроп, сжатие в обработчике python а потом отправить на ресурс. Например, зная путь к файлу можно его открыть:

```python
with open(filename, "rb") as image_file:
      encoded_string = base64.b64encode(image_file.read()).decode('utf-8')
```
## Диалоги открытия и сохранения файла из экрана
Открытие файла через диалог(пикер) состоит из комманды-переменной и обработчика события.
**OpenExternalFile** , пустой параметр – команда запуска диалога, при открытии файла генерируется событие **FileOpen** которое можно перехватить в обработчике типа _pythonbytes_ в который попадает байт-массив открытого файла.

Также доступно сохранение файла.
**SaveExternalFile** , параметр: 
`{"path": "путь к внутреннему файлу", "default": "имя по умолчанию"}`
Команда запуска диалога выбора локации сохранения файла и имени файла (можно выбрать имя по умолчанию). При успешном сохранении генерируется событие onInput `listener = FileSave`

## Сохранение в Downloads
В Java классе SimpleUtilites появилась функция 
**download_file("имя файла")** которая сохраняет файл (сформированный в папке приложения) во внешнюю папку Downloads (коллекция Загрузки). Таким образом можно сбрасывать информацию в виде файлов безусловно.

## Статические ресурсы
Различные статические декорации (картинки, выводимые в экранах или меню) имеет смысл передавать вместе с конфигурацией. При загрузке конфигурации они сохраняются во временные файлы под определенным uuid, а для обращения к ним требуется ключ, указанный на закладке Медиафайлы Если статический ресурс – картинка, то для вывода на форму достаточно указать ее ключ c префиксом **^** . Т.е. у элемента Картинка в «Заполнении поля» будет стоять `^kitty` , где kitty – ключ картинки на закладке Медиафайлы Любой статический ресурс можно получить по ключу:
[![Pastedimage20240119104502.png](/files/Pastedimage20240119104502.png =750x)](/files/Pastedimage20240119104502.png)
```python
from ru.travelfood.simple_ui import SimpleUtilites as suClass
filename = suClass.get_stored_file("kitty")
```

## Изображения
Файлы, генерируемые на устройстве, это в том числе изображения с камеры или медиагалереи устройства, загружаемые с ключом mm_local, работа с которыми описана в [соответствующих разделах](../Screens/Screens). У подобных файлов при сохранении генерируется uuid, по которому к нему можно обратиться. Этот uuid равен имени файла. Можно просто работать с именем файла, запоминая его в своих структурах данных. Например при фотографировании в режиме mm_local в переменную (допустим переменная камеры называется photo) сохраняется абсолютный путь с приставкой _path, то есть в данном случае будет переменная photo_path `hashMap.get("photo_path")`. Также, все идентификаторы хранятся в хранилище ключ-значение к которому есть доступ через [getfiles](../Screens/Screens). Возможно этот механизм излишен, учитывая что первично у разработчика всегда есть абсолютный путь к файлу и хранение его он может организовать сам. Обращаться к там файлам в контейнерах следует через **~** чтобы система поняла что вы передаете картинку в виде файла. Дело в том что по умолчанию она ожидает base64 строку. По возможности используйте файлы а не base64, особенно в карточках списков – это быстрее. Более подробно это описано в графе [тут](../Screens/Screens). В пакет приложения включен Pillow которая дает возможность работать с картинками – ресайз и т.д. Вот пример открытия файла, и отправки его запросом
```python
import json
import requests
import base64
from PIL import Image
import os
from pathlib import Path
from io import BytesIO
from requests.auth import HTTPBasicAuth

#...

filename="path_to_file.jpg"
if os.path.exists(filename):
    image = Image.open(filename)
    image.resize((500, 500))
    buffered = BytesIO()
    image.save(buffered, format="JPEG")
    img_str = base64.b64encode(buffered.getvalue()).decode('utf-8')
    username = hashMap.get("WS_USER")
    password = hashMap.get("WS_PASS")
    url = hashMap.get("WS_URL")
	requests.post(url+'/data_upload', auth=HTTPBasicAuth(username, password,),
         headers={'Content-type': 'application/json', 'Accept':     'text/plain'},data=json.dumps({"file":filename,"base64":img_str}))
```
Приведенный выше пример передает содержимое в виде строки base64, однако в случае с файлами, особенно большими лучше использовать вариант с потоковой передачей, которую поддерживает requests:
```python
with open('image-1.png', 'rb') as img_1:
    r = requests.post(url, auth=basic, data=img_1, headers=headers)
```

## Полезные утилиты для работы с файлами в SimpleUtilites
Для удобства есть возможность генерировать временные файлы нужного расширения методом **get_temp_file**
```python
from ru.travelfood.simple_ui import SimpleUtilites as subclass
output_file = suClass.get_temp_file("txt")
```
Получить абсолютный путь к папке, в которой можно хранить свои файлы можно с помощью **get_temp_dir()**
`targetDir = suClass.get_temp_dir()