---
title: NoSQL
description: 
published: true
date: 2024-02-16T13:35:04.063Z
tags: 
editor: markdown
dateCreated: 2024-02-16T08:23:40.503Z
---

# NoSQL
Параллельно с **SQL** данные на устройстве можно хранить в NoSQL- СУБД. Этот режим обладает множеством преимуществ, главное из которых - простота разработки. Хранение в NoSQL не исключает хранение в SQL - можно одновременно использовать и то и то.
## SimpleBase
SimpleBase - это открытый проект безсерверной JSON-ориентированной СУБД на Python который встроен в SimpleUI в виде Python-библиотеки и параллельно реализован в apk в виде Java-реализации. В SimpleWEB, соотвественно, просто достаточно подключить библиотеку из pip. 
Документация: [https://simplebase.readthedocs.io/en/latest](https://simplebase.readthedocs.io/en/latest)
GitHub : [https://github.com/dvdocumentation/simplebase](https://github.com/dvdocumentation/simplebase)
Это наиболее простой способ работы с локальным хранением – по сути чистый JSON, для которого не нужно знать SQL, да и вообще на JSON в стеке симпла буквально все команды, разметки экрана и переменных. Например: пришли документы с сервера по http – это JSON, его не надо растаскивать по таблицам а можно хранить как есть, работать с ним как есть, выводить на экран, заполнять экранные списки – JSON, обратно отсылать – то же JSON без собирания и упаковки. Получается это намного проще SQL, а из стека нужно знать только работу со словарями и списками - итерации и вот это вот все. За счет особой архитектуры работы с данными удалось добиться показателей скорости, сравнимых с SQL в критичных участках: добавление данных, поиск по индексу, текстовый поиск. 
Свойства SimpleBase:
> - Мгновенное добавление новых записей в коллекции независимо от размера коллекции благодаря специальной архитектуре хранения.
> - Более быстрая работа с операциями, за счет того, что не требуется кодировать/декодировать всю коллекцию (которая может быть очень большой)
> - Коллекции всегда хранятся в оперативной памяти с отслеживанием изменений одновременно: данные перечитываются с диска только в том случае, если они были изменены другим процессом.
> - ACID для многопользовательской и многопоточной работы
> - Два типа индексов для ключевых типов запросов — хеш-индекс и специальное B-дерево для полнотекстового поиска.
> - Поддержка транзакций (сессий)
### Интеграция SimpleBase на уровне Python-библиотеки
Базы SimpleBase хранятся в специальном каталоге SimpleBase в папке приложения. Базу можно располагать где угодно, но желательно прописывать путь к этой папке, для того, чтобы нативные функции могли работать с этой базой тоже. Для этого есть функция get_simplebase_files в классе SimpleUtilities
Инициализация будет выглядеть так
```python
from pysimplebase import SimpleBase
from ru.travelfood.simple_ui import SimpleUtilites as suClass
db = SimpleBase("test_db", 
				path=suClass.get_simplebase_dir(),
				timeout=200)
```
Вся остальная работа с СУБД согласно документации к SimpleBase
## Старая NoSQL
В NoSQL СУБД данные хранятся в режиме «ключ - значение» а не в таблицах. В любой ключ можно записать любое значение - текст, JSON и т.д. Т.е. работа происходит с неструктурированной информацией. Структуры данных типа документов и справочников удобнее хранить в JSON.
С NoSQL базами можно работать через стек переменных и непосредственно из python– обработчиков. В случае работы через методы класса NoSQL преимуществом является получение результата сразу, также то что просты типы можно использовать как есть, без преобразования в строку.
### Работа с NoSQL ключ-значение  
```Python
Для работы необходимо подключить класс NoSQL и создать объект. Импортировать класс можно двумя способами:
1. from ru.travelfood.simple_ui import NoSQL as noClass
2. from java import jclass
	noClass = jclass("ru.travelfood.simple_ui.NoSQL")`
Далее нужно создать объект, указав в качестве параметра имя существующей или новой БД. Она будет создана при необходимости
 
ncl = noClass("test_new_nosql")` 
```
Методы объекта:
- **put(ключ, значение, регистрировать_в_очереди)** – помещает значение в указанный ключ. Значения типов строка, число, булево – можно помещать как есть. JSON лучше преобразоывать в строку. Пример:
```Python
ncl.put("k1", "Это строка", True)
```
- **get(ключ)** – получает значение по ключу
- **delete(ключ)** – удаляет ключ
- **destroy()** – уничтожает все ключи базы
- **getallkeys()** – получить список всех ключей базы в виде строки формата JSON-массива строк
- **findJSON(поле,значение)** – медленный поиск среди всех объектов базы которые имеют тип JSON , объектов, в **поле** которых есть **значение**. Возвращает строку с JSON-массивом найденных объектов. Лучше использовать в базах, где мало значений, если значений много -лучше испоьзовтаь поиск с индексом.
Пример:
```python
j3 = {"name": "Дарья", 
	  "surname": "Смирнова"}
ncl.put("jk3",json.dumps(j3,ensure_ascii=False),True)
#Поиск без индекса
res = ncl.findJSON("name", "Дарья")
jres = json.loads(str(res).encode("utf-8"))
```
- **run_index** (имя_индекса,поле – создание индекса по JSON-объектам для дальнейшего использования для поиска. Создает, асинхроннно индекс, состоящий из объектов с указанным полем.
- **findJSON_index** (имя_индекса, поле, значение) – поиск по индексу. Возвращает строку с JSON-массивом найденных объектов. Поиск ведется по ключам, в которых записаны JSON-строки объектов.
### Работа с NoSQL ключ-значение через стек переменных (команды-переменные)
Вся работа происходит через Переменные (в Python - hashMap). Например в Переменные передается команда к СУБД и данные, которые надо вставить. Данные, запрошенные из СУБД также возвращаются в Переменные.
В конфигурации можно определить название СУБД в поле «Имя базы noSQL» , чтобы у каждой конфигурации была собственная СУБД, а можно не использовать разделение, например чтобы можно было использовать общие данные.
1)Запись, чтение, удаление:
 - **(put_ключ, переменная)** - записать данные в СУБД в ключ    
 - **(get_ключ, переменная)** - получить данные из СУБД из ключа в переменную. Если в обработчике есть команды get_, find_ и finindex_ система извлекает данные из СУБД в Переменные, после чего вызывает событие «_results» (как бы новый такт обработчика)     
 - **(del_ключ,)** - удалить ключ     
 - **(getallkeys, переменная)** - получить список всех ключей     
2)Поиск и индексы:
 - **(find_имяпеременной, имяполя=значение)** - «условно медленный» поиск по объектам в СУБД. в «имяпеременной» возвращается JSON-массив найденных объектов. «имяполя» - имя поля в корне JSON объектов по которому будет вестись поиск. Вид сравнение можно использовать «=»(точное сравнение) или «~»(вхождение подстроки). Значение - значение поиска.     
 - **(createindex_имяиндекса, имяполя)** и (**findindex_имяиндекса, имяполя=значение**). Индексы - загруженные в память таблицы значение - ключ, по которым происходит более быстрый поиск. Т.е. если индекс задать заранее, поиск будет произвдиться очень быстро - ведь это поиск по массивы у памяти а не в СУБД. Поэтому где в начале, возможно при запуске конфигурации, следует создать нужные индексы командой **createindex_**. Далее использовать команду **findindex_**, где в качестве параметра поиска уже использовать имя ранее созданного индекса.
 
3)Очередь
Очередь используется для автоматической фиксации изменённых или добавленных объектов. Это используется например для синхронизации - всегда можно получить список ключей, измененных на устройстве, чтобы выгрузить в основную систему. Очередь пишется автоматически, но ее можно выключить например при загрузке данных из учетной системы командой («StopQueue»,»»)
 - **_sys_queue** - переменная-очередь, в которой всегда содержится список ключей объектов, разделенных через «;»
 - **(removequeue,ключ)** - удалить ключ из очереди (например, при успешной выгрузке)
 