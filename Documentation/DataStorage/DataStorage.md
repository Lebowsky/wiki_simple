---
title: DataStorage
description: 
published: true
date: 2024-01-25T14:03:32.625Z
tags: 
editor: markdown
dateCreated: 2024-01-25T07:43:19.215Z
---

# SQL
## Основные команды SQL
Стандартным для Android является встроенный SQLite. Его преимущества в том, что это классическая реляционная СУБД – быстрая работа, SQL запросы, агрегирующие функции. Например найти товар по штрихкоду из 1 миллиона записей, да еще по сложному условию -это не сделать быстрее чем на SQL с индексами. Или например посчитать агрегаты – сумму по строкам таблицы. Опять же быстрее SQL с этим никто не справиться.
Можно завести несколько СУБД в рамках приложения.
К SQL можно обращаться из Python напрямую, в т.ч использую ORM но рекомендуется использовать единую точку входа(SQLProvider) либо через команды переменные либо через класс **SimpleSQLProvider** в Python либо через нативные обработчики (они также используют SimpleSQLProvider).Т.е. при обращении к SQL используется Java-класс реализующий монопольное подключение к СУБД и общий поток событий.
Можно работать с SQL через команды-переменные либо(если из питон-обработчиков) использовать вызовы специального класса в явном виде.
Справочник команд-переменных:
>### **SQLConnectDatabase**
>`hashMap.put("SQLConnectDatabase", "test1.DB")`
>Так как указывается имя базы предполагается что можно использовать несколько баз, помимо дефолтной.

>### **SQLExec**
>`{"query": "SQL statement", "params": "parameters with delimiter"}`
>Например:
>```sql
>sql_query = "CREATE TABLE IF NOT EXISTS Record
>		(id integer primary key autoincrement,
>		 art text,
>		 barcode text, 
>		 name text, 
>		 qty real)"
>```
>```python
>hashMap.put("SQLExec",
>		     json.dumps({"query": sql_query,
>		     "params":""}))
>```
>Выполняет запрос на изменение БД (все кроме SELECT), параметры в запросе указываются в неименованном виде, а в params, перечисляются через запятую

>### **SQLExecMany**
>`{"query": "SQL statement", "params": "parameters with delimiter"}`
> Выполняет запрос в BULK-режиме с массивом из множества записей. Параметры запроса передаются в виде массива записей в неименованном виде (через ?)
> Пример:
> ```SQL
> sql_query = "INSERT INTO goods(art,barcode,nom) 
> 		   VALUES(?,?,?)"
> ```
> ```python
> values=[]
> for i in range(1,3):
> 	record =[]
> 	record.append("AA"+str(i))
> 	record.append("22"+str(i))
> 	record.append(f"Товар переменной {str(i))}"
> 	values.append(record)
> 
> hashMap.put("SQLExecMany",
>			json.dumps({"query": sql_query,
>			"params": json.dumps(values, ensure_ascii=False)}))
> ```
> _


>### **SQLParameter**
>Имеет смысл для SQLExecMany для передачи массива записей в качестве параметра из других обработчиков

>### **SQLQuery**
>`{"query": "SQL statement","params": "parameters with delimiter"}`
> Запрос типа SELECT, который пишет выборку в виде JSON-массива в стек переменных в SQLResult
> Пример query:
>```SQL
>sql_query = "SELECT name FROM sqlite_master WHERE type='table'" 
>```
>Пример запроса:
>```python
>info = requests.post(f"url={our_url}&query={sql_query}&params=",
>			headers={'Content-Type': 'Application/json;charset=utf-8'})
>```

>### **SQLQueryMany**
>`{"query": "SQL statement","params": "parameters with delimiter"}`
> Запрос типа SELECT, который пишет выборку в виде JSON-массива во временный файл и в параметре SQLResultFile возвращает имя этого файла. Для очень больших выборок (>0.5 млн строк)

Те же функции можно вызывать из импортируемого класса напрямую. Этот вариант хорош тем что результат получаешь сразу а не на конец шага и его лучше использовать в python-обработчиках.

```python
from ru.travelfood.simple_ui import SimpleSQLProvider as sqlClass
sql = sqlClass()
  success=sql.SQLExec("insert into goods(art,barcode,nom) values(?,?,?)","111222,22000332323,Некий товар")
  res = sql.SQLQuery("select * from goods where id=1","")
  if success:
      hashMap.put("toast",res)
```

## Работа с SQL напрямую через конфигурацию
Можно работать с SQL не через команды-переменные и не через Python, а напрямую. Это один из «нативных» обработчиков, работающих через единый провайдер. Данный вид обработчика удобно использовать для простых ситуаций – вытащить переменные из SQL по отбору, записать простой insert или update и т.д. Что например можно делать этим инструментом:

1. Передавать любые поля в запрос из стека переменных через @, также как они передаются на форму например. Например, этот запрос запишет в таблицу name и barcode. Это касается и переменных запроса и условий.
![Pastedimage20240118124900.png](/files/Pastedimage20240118124900.png)
2. Select распознается как выборка и пишет результат в переменные в виде JSON-массива (такой же как если вызвать это через команду переменные или класс)
![Pastedimage20240118124653.png](/files/Pastedimage20240118124653.png)
3. Но если в select написать limit 1 то обработчик запишет переменные 1й строки сразу в стек переменных. Удобно например при открытии сделать выборку, сразу получить переменные и привязать их на форму – без парсинга и т.е.
![Pastedimage20240118124948.png](/files/Pastedimage20240118124948.png)

# NoSQL
Параллельно с **SQL** данные на устройстве можно хранить в NoSQL- СУБД. Этот режим обладает множеством преимуществ, главное из которых - простота разработки. Хранение в NoSQL не исключает хранение в SQL - можно одновременно использовать и то и то.
## SimpleBase
SimpleBase - это открытый проект безсерверной JSON-ориентированной СУБД на Python который встроен в SimpleUI в виде Python-библиотеки и параллельно реализован в apk в виде Java-реализации. В SimpleWEB, соотвественно, просто достаточно подключить библиотеку из pip. 
Документация: [https://simplebase.readthedocs.io/en/latest](https://simplebase.readthedocs.io/en/latest)
GitHub : [https://github.com/dvdocumentation/simplebase](https://github.com/dvdocumentation/simplebase)
Это наиболее простой способ работы с локальным хранением – по сути чистый JSON, для которого не нужно знать SQL, да и вообще на JSON в стеке симпла буквально все команды, разметки экрана и переменных. Например: пришли документы с сервера по http – это JSON, его не надо растаскивать по таблицам а можно хранить как есть, работать с ним как есть, выводить на экран, заполнять экранные списки – JSON, обратно отсылать – то же JSON без собирания и упаковки. Получается это намного проще SQL, а из стека нужно знать только работу со словарями и списками - итерации и вот это вот все. За счет особой архитектуры работы с данными удалось добиться показателей скорости, сравнимых с SQL в критичных участках: добавление данных, поиск по индексу, текстовый поиск. 
Свойства SimpleBase:
> - Мгновенное добавление новых записей в коллекции независимо от размера коллекции благодаря специальной архитектуре хранения.
> - Более быстрая работа с операциями, за счет того, что не требуется кодировать/декодировать всю коллекцию (которая может быть очень большой)
> - Коллекции всегда хранятся в оперативной памяти с отслеживанием изменений одновременно: данные перечитываются с диска только в том случае, если они были изменены другим процессом.
> - ACID для многопользовательской и многопоточной работы
> - Два типа индексов для ключевых типов запросов — хеш-индекс и специальное B-дерево для полнотекстового поиска.
> - Поддержка транзакций (сессий)

### Интеграция SimpleBase на уровне Python-библиотеки
Базы SimpleBase хранятся в специальном каталоге SimpleBase в папке приложения. Базу можно располагать где угодно, но желательно прописывать путь к этой папке, для того, чтобы нативные функции могли работать с этой базой тоже. Для этого есть функция get_simplebase_files в классе SimpleUtilities
Инициализация будет выглядеть так
```python
from pysimplebase import SimpleBase
db = SimpleBase("test_db", 
				path=suClass.get_simplebase_dir(),
				timeout=200)
```
Вся остальная работа с СУБД согласно документации к SimpleBase

## Старая NoSQL
В NoSQL СУБД данные хранятся в режиме «ключ - значение» а не в таблицах. В любой ключ можно записать любое значение - текст, JSON и т.д. Т.е. работа происходит с неструктурированной информацией. Структуры данных типа документов и справочников удобнее хранить в JSON.
С NoSQL базами можно работать через стек переменных и непосредственно из python– обработчиков. В случае работы через методы класса NoSQL преимуществом является получение результата сразу, также то что просты типы можно использовать как есть, без преобразования в строку.

### Работа с NoSQL ключ-значение


Для работы необходимо подключить класс NoSQL и создать объект. Импортировать класс можно двумя способами:
1. from ru.travelfood.simple_ui import NoSQL as noClass
2. from java import jclass
	`noClass = jclass("ru.travelfood.simple_ui.NoSQL")`

Далее нужно создать объект, указав в качестве параметра имя существующей или новой БД. Она будет создана при необходимости
`ncl = noClass("test_new_nosql")`
Методы объекта:
- **put(ключ, значение, регистрировать_в_очереди)** – помещает значение в указанный ключ. Значения типов строка, число, булево – можно помещать как есть. JSON лучше преобразоывать в строку. Пример: `ncl.put("k1", "Это строка", True)`
- **get(ключ)** – получает значение по ключу
- **delete(ключ)** – удаляет ключ
- **destroy()** – уничтожает все ключи базы
- **getallkeys()** – получить список всех ключей базы в виде строки формата JSON-массива строк
- **findJSON(поле,значение)** – медленный поиск среди всех объектов базы которые имеют тип JSON , объектов, в **поле** которых есть **значение**. Возвращает строку с JSON-массивом найденных объектов. Лучше использовать в базах, где мало значений, если значений много -лучше испоьзовтаь поиск с индексом.
Пример:
```python
j3 = {"name": "Дарья", 
	  "surname": "Смирнова"}
ncl.put("jk3",json.dumps(j3,ensure_ascii=False),True)

#Поиск без индекса
res = ncl.findJSON("name", "Дарья")
jres = json.loads(str(res).encode("utf-8"))

```

- **run_index** (имя_индекса,поле – создание индекса по JSON-объектам для дальнейшего использования для поиска. Создает, асинхроннно индекс, состоящий из объектов с указанным полем.
- **findJSON_index** (имя_индекса, поле, значение) – поиск по индексу. Возвращает строку с JSON-массивом найденных объектов. Поиск ведется по ключам, в которых записаны JSON-строки объектов.

### Работа с NoSQL ключ-значение через стек переменных (команды-переменные)

Вся работа происходит через Переменные (в Python - hashMap). Например в Переменные передается команда к СУБД и данные, которые надо вставить. Данные, запрошенные из СУБД также возвращаются в Переменные.
В конфигурации можно определить название СУБД в поле «Имя базы noSQL» , чтобы у каждой конфигурации была собственная СУБД, а можно не использовать разделение, например чтобы можно было использовать общие данные.

1)Запись, чтение, удаление:
 - **(put_ключ, переменная)** - записать данные в СУБД в ключ    
 - **(get_ключ, переменная)** - получить данные из СУБД из ключа в переменную. Если в обработчике есть команды get_, find_ и finindex_ система извлекает данные из СУБД в Переменные, после чего вызывает событие «_results» (как бы новый такт обработчика)     
 - **(del_ключ,)** - удалить ключ     
 - **(getallkeys, переменная)** - получить список всех ключей     

2)Поиск и индексы:
 - **(find_имяпеременной, имяполя=значение)** - «условно медленный» поиск по объектам в СУБД. в «имяпеременной» возвращается JSON-массив найденных объектов. «имяполя» - имя поля в корне JSON объектов по которому будет вестись поиск. Вид сравнение можно использовать «=»(точное сравнение) или «~»(вхождение подстроки). Значение - значение поиска.     
 - **(createindex_имяиндекса, имяполя)** и (**findindex_имяиндекса, имяполя=значение**). Индексы - загруженные в память таблицы значение - ключ, по которым происходит более быстрый поиск. Т.е. если индекс задать заранее, поиск будет произвдиться очень быстро - ведь это поиск по массивы у памяти а не в СУБД. Поэтому где в начале, возможно при запуске конфигурации, следует создать нужные индексы командой **createindex_**. Далее использовать команду **findindex_**, где в качестве параметра поиска уже использовать имя ранее созданного индекса.
 
3)Очередь
Очередь используется для автоматической фиксации изменённых или добавленных объектов. Это используется например для синхронизации - всегда можно получить список ключей, измененных на устройстве, чтобы выгрузить в основную систему. Очередь пишется автоматически, но ее можно выключить например при загрузке данных из учетной системы командой («StopQueue»,»»)
 - **_sys_queue** - переменная-очередь, в которой всегда содержится список ключей объектов, разделенных через «;»
 - **(removequeue,ключ)** - удалить ключ из очереди (например, при успешной выгрузке)
