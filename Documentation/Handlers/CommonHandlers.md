---
title: CommonHandlers
description: 
published: true
date: 2024-02-05T09:00:26.776Z
tags: 
editor: markdown
dateCreated: 2024-01-25T07:43:39.402Z
---

# Общие обработчики
[![Pastedimage20240122162004.png](/files/Pastedimage20240122162004.png =700x)](/files/Pastedimage20240122162004.png)
> **onLaunch** 
> При запуске перед формированием главного меню. Так как вызывается до формирования меню, то в этом обработчике например можно перерисовать меню или заполнить плитки. По сути заменяет [Таймер](../Screens/Screens) с периодом -1, который также можно использовать для этой цели. 
{.is-info}

> **onIntentBarcode**
> Получение штрихкода через подписку на Intent на уровне платформы в целом(до экрана). Например может использоваться для работы со сканером без экранов, либо для предпроверки штрихкодов. В переменные помещается: listener=”barcode”, barcode - штрихкод 
{.is-info}


>**onBluetoothBarcode**
>Получение штрихкода от подключенного Bluetooth-сканера на уровне платформы в целом. В переменные помещается: listener=”barcode”, barcode - штрихкод {.is-info}
 
> **onBackgroundCommand** 
> Получение события onBackgroundCommand в сервисе событий, отправленного из какого то обработчика (командой-переменной BackgroundCommand ) . В listener помещается аргумент команды BackgroundCommand 
{.is-info}

> **onRecognitionListenerResult** 
> События по результату распознавания речи после использования команды voice в сервисе. В переменные помещается: listener=”voice_success”, voice_result="распознанная фраза" 
{.is-info}

> **onIntent** 
> Получение сообщения от другого Андроид-приложения (подписка на Intent). Из сообщения извлекается поле “body” и помещается в переменную. Через него можно передавать данные от другого приложения. 
{.is-info}

> **onWebServiceSyncCommand**
> Получение команды через встроенный веб-сервер приложения. На адрес веб-сервиса <адрес устройства>:8095 можно послать запрос GET или POST вида 
> `http:/{ip}:8095?mode=SyncCommand&listener={NameListener}`
> Пример отправки
>```python
>query = 'http://127.0.0.1:8095/?mode=SyncCommand&listener=put_data' 
>json_data = 'json файл' 
>our_headers = {'Content-Type': 'Application/json; charset=utf-8'} 
>requests.post(query, json=json_data, headers=our_headers)
>```
> Обработчик может что то поместить в переменные и все переменные отправляются назад в виде JSON объекта. Но, можно также не отправлять все переменные а переопределить ответ(например сделать не JSON а строковый) с помощью команды WSResponse 
{.is-info}


> **onSQLDataChange** и **onError**
> Возникают при выполнении любой записи в SQL если запрос идёт через SQL-провайдера (onError в случае ошибки). Таким образом можно например перехватывать записываемые данные централизованно и помещать их в очередь на отправку. 
{.is-info}


> **onOpenFile**
> Событие, в котором можно получить файл, открытый приложением. С приложением можно поделиться текстовым файлом любым способом (через Поделиться… и через Открыть с помощью…) даже если приложение не открыто. При этом срабатывает обработчик и в переменные content и extra_text помещается содержимое файла и ссылка на файл.
{.is-info}

# События
Кнопки контейнеров, диалоги ввода, штрихкоды и другие управляющие элементы передают события которые можно использовать в алгоритмах. Как только происходит событие происходит запрос ввода либо обработка оффлайн события
За это отвечают 2 переменные
- event 
- listener

 В _event_ пишется тип события: Input (любой ввод – кнопки, штрихкоды и т.д.), onResult(экран диалога) и onStart(запуск экрана) и другие в _listener_ пишется расшифровка- либо переменная (кнопка) либо зарезервированное название операции barcode, signature, photo

 Все события в платформе возникают в 3х ключевых точках:
- События экрана
- События ActiveCV
- События системы в целом.

 Также события могут запускаться из кода или например по окончанию каких то фоновых механизмов. На любое событие платформы в независимости, где это событие происходит (экраны, ActiveCV, общие события платформы) можно подписать любое количество различных любых обработчиков (массив). Этот массив предполагает чередование любого количества обработчиков любых типов и режимов исполнения (синхронные и асинхронные). Этот массив можно определить в конфигурации с помощью конструктора, запустить командой, запустить по псевдониму. Он может состоять из одного действия а может из множества. Например так это выглядит в конструкторе
[![Pastedimage20240112132211.png](/files/Pastedimage20240112132211.png =700x)](/files/Pastedimage20240112132211.png)

# Строковые обработчики
Строковое написание обработчика аналогично определению в конфигураторе, далее я буду использовать строковый синтаксис. Пример массива из одного простого синхронного обработчика в строковом виде:
`[{"action": "run", "type": "python", "method": "post_online"}]`
В общем случае синтаксис состоит из следующих элементов:
**action** – может быть: **run** - обычный, синхронный запуск, **runasync** – асинхронный запуск в фоне, с возвратом в синхрон, **runprogress** - синхронный запуск с прогресс-баром на время выполнения долгого процесса, рекомендуется для длительных процессов 
**type** – тип интерпретатора (где обработчик будет выполняться). На текущий момент это Python (в двух вариантах python и pythonargs), онлайн (на стороне бекенда), нативная обработка (sql,http,set).
**method** – в случае интерпретаторов – это имя функции, также для нативных обработчиков это может быть сразу команда с параметрами **postExecute** – это поле имеет смысл для асинхронных обработчиков, туда можно вставить массив обработчиков которые будут выполнены по завершению (а в нем может быть еще один массив и т.д. – рекурсия)
